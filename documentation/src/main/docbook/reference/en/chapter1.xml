<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="chapter1">
  <title>A Jspresso application from A to Z</title>

  <para>This chapter will help you to understand the basics of the Jspresso
  application framework and how to work with it.</para>

  <section>
    <title>Setting-up the development environment</title>

    <para>One of the interesting feature of Jspresso is its native integration
    with standard build tools. All the complex build process is completely
    handled in <ulink url="http://maven.apache.org/">Maven</ulink>. Jspresso
    also offers a Maven archetype to quickly setup your project and import it
    directly in <ulink url="http://www.eclipse.org/">Eclipse</ulink>.</para>

    <section>
      <title>Installing the tools</title>

      <para>Download, install and configure the following tools :</para>

      <itemizedlist>
        <listitem>
          <para>The <ulink
          url="http://java.sun.com/javase/downloads/index.jsp">Java
          Development Kit</ulink> for your platform (JDK 6+).</para>
        </listitem>

        <listitem>
          <para>The <ulink url="http://maven.apache.org/download.html">Apache
          Maven</ulink> project management tool (3.0+).</para>
        </listitem>

        <listitem>
          <para>The <ulink url="http://www.eclipse.org/downloads/">Eclipse IDE
          for Java EE Developers</ulink> (3.6+).</para>
        </listitem>

        <listitem>
          <para>the <ulink
          url="http://tomcat.apache.org/download-60.cgi">Apache Tomcat servlet
          container</ulink> (6.0+).</para>
        </listitem>
      </itemizedlist>

      <para>You must also increase the java heap space allocated to Maven
      :</para>

      <itemizedlist>
        <listitem>
          <para>on windows : <code>set MAVEN_OPTS=-Xmx512m</code> (or set it
          as a user env variable)</para>
        </listitem>

        <listitem>
          <para>on linux : <code>export MAVEN_OPTS=-Xmx512m</code> (or set it
          as a user env variable)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Generating the skeleton project</title>

      <para>This is a one-step operation using the Jspresso application Maven
      archetype. Move to your Eclipse workspace and perform :</para>

      <itemizedlist>
        <listitem>
          <para><code>mvn archetype:generate
          -DarchetypeCatalog=http://repository.jspresso.org/maven2/</code></para>
        </listitem>
      </itemizedlist>

      <para>And choose the <quote>Jspresso Application
      Archetype</quote>.</para>

      <para>Then fill-in the questions with the following answers :</para>

      <itemizedlist>
        <listitem>
          <para><quote>groupId</quote> :
          <code>org.jspresso.hrsample</code></para>
        </listitem>

        <listitem>
          <para><quote>artifactId</quote> : <code>hrsample</code></para>
        </listitem>

        <listitem>
          <para><quote>package</quote> :
          <code>org.jspresso.hrsample</code></para>
        </listitem>

        <listitem>
          <para><quote>version</quote> : <code>1.0-SNAPSHOT</code></para>
        </listitem>
      </itemizedlist>

      <para>This will generate a complete project ready to be compiled and
      packaged under the <filename>hrsample/</filename> directory. So move to
      the generated directory and type :</para>

      <itemizedlist>
        <listitem>
          <para><code>mvn package</code></para>
        </listitem>
      </itemizedlist>

      <para>The operation may take some time to finish since Maven will
      download all the needed plugins and dependencies in its local
      repository. Just wait for the <quote>BUILD SUCCESSFUL</quote> message
      and you should have a packaged <filename>hrsample-webapp.war</filename>
      in the <filename>hrsample/webapp/target/</filename> directory.</para>
    </section>

    <section>
      <title>Importing the project in Eclipse</title>

      <para>Follow the <ulink url="???">installation steps</ulink> described
      on the Jspresso site and then import the project skeleton you've
      generated using the M2Eclipse project import wizard.</para>

      <para>The development environment is now set-up. We can begin the Human
      Resources sample application coding.</para>
    </section>
  </section>

  <section>
    <title>The human resources (HR) sample application</title>

    <para>The human resources application is a simple yet comprehensive
    business application targeted at managing a company organization and the
    employees who work in it. It will demonstrate how Jspresso can handle a
    domain model with its relationships and its constraints, present it to the
    end-user for manipulation through various built-in views and actions,
    handle security through profile management, distribute the frontend across
    the network, ...</para>

    <section>
      <title>The domain model</title>

      <para>To quickly introduce the HR domain model, let's dive into the
      following UML class diagrams. As a general rule to make the diagrams
      more readable, attributes must be considered as getter / setter
      pairs.</para>

      <para>The <link linkend="commons-cd">commons class diagram</link>
      describes commonly used interfaces and classes.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>The traceable interface is implemented by entities for which
          we need to record when it was saved for the first time and when it
          was last updated. Of course, these tracing elements must be made
          read-only to the end-user since they are automatically managed by
          the application.</para>
        </listitem>

        <listitem>
          <para>The nameable is implemented by entities having a name. A name
          has a max length of 64 characters and is mandatory. Nameable
          implements a service which formats its name (a really simple service
          only for demonstration purpose).</para>
        </listitem>

        <listitem>
          <para>The contact information component is used by entities that
          have contact details (address, phone, email, ...). A contact
          information points to one and only one city. A city is nameable and
          has a zip code of maximum length 10 characters.</para>
        </listitem>

        <listitem>
          <para>An event is a piece of text which is traceable</para>
        </listitem>
      </itemizedlist>

      <figure id="commons-cd">
        <title>Commons class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../uml/commons-cd.PNG" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="employee-cd">employees class diagram</link>
      describes what an employee is.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>An employee is nameable and traceable. An employee has
          :</para>

          <itemizedlist>
            <listitem>
              <para>a first name (his last name is inherited by the nameable
              interface)</para>
            </listitem>

            <listitem>
              <para>a social security number which is composed by exactly 10
              digits and which is unique among all employees</para>
            </listitem>

            <listitem>
              <para>a gender (male or female)</para>
            </listitem>

            <listitem>
              <para>a birth date</para>
            </listitem>

            <listitem>
              <para>a hire date in the company</para>
            </listitem>

            <listitem>
              <para>a contact information</para>
            </listitem>

            <listitem>
              <para>a preferred color</para>
            </listitem>

            <listitem>
              <para>a flag indicating if (s)he is married</para>
            </listitem>

            <listitem>
              <para>a salary</para>
            </listitem>

            <listitem>
              <para>a photo</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>An employee must provide a method to compute his age based on
          his birth date.</para>
        </listitem>

        <listitem>
          <para>An employee has an ordered list of events.</para>
        </listitem>
      </itemizedlist>

      <figure id="employee-cd">
        <title>Employees class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../uml/employees-cd.PNG" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="organization-cd">organization class
      diagram</link> describes how the company is structured in departments
      and teams.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>A company is structured in organizational units. An
          organizational unit may be a department or a team. An organizational
          unit has an identifier (<emphasis>ouId</emphasis>) which is formed
          by a 2 letter code followed by a dash followed by a 3 digit number
          (<emphasis>IS-001</emphasis> for instance). Each organizational unit
          has a manager who is an employee of the company it belongs to. An
          employee can at most manage one organizational unit. An
          organizational unit is nameable, traceable and has contact
          information as well as a company has.</para>
        </listitem>

        <listitem>
          <para>The company may have one or more departments and a department
          belongs to one and only one company.</para>
        </listitem>

        <listitem>
          <para>A department may have one or more teams and a team belongs to
          one and only one department. Each team is composed by one or more
          employees.</para>
        </listitem>

        <listitem>
          <para>An employee belongs to one and only one company. An employee
          may belong to zero or more teams.</para>
        </listitem>
      </itemizedlist>

      <figure id="organization-cd">
        <title>Organization class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../uml/organization-cd.PNG" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The application workspaces</title>

      <para>The HR application is divided in 3 workspaces.</para>

      <section>
        <title>The organization management workspace</title>

        <para>This workspace manages a company structure in terms of
        organizational units. The end-user may create/delete/update a company,
        create/delete/update its organizational units and structure them in
        the organization. The end-user may compose the employee teams, assign
        an organisational unit manager but won't be able to
        create/update/delete an employee. The organization must be displayed
        in a hierarchical (tree) view.</para>
      </section>

      <section>
        <title>The employees management module</title>

        <para>This workspace manages a company staff. The end-user can
        retrieve the company employees and create/update/delete an
        employee.</para>
      </section>

      <section>
        <title>The master data management module</title>

        <para>This module manages the application master data. As of now, the
        master data are only made of the cities available to compose the
        addresses.</para>
      </section>
    </section>

    <section>
      <title>The profiles</title>

      <para>The HR application offers 3 profiles.</para>

      <section>
        <title>The organization manager profile</title>

        <para>A logged-in user having the organization manager profile will be
        granted access to the organization management workspace as well as the
        master data management workspace but he won't be able to access the
        employee management workspace.</para>
      </section>

      <section>
        <title>The staff manager profile</title>

        <para>A logged-in user having the staff manager profile will be
        granted access to the employee management workspace as well as the
        master data management workspace but he won't be able to access the
        organization management workspace.</para>
      </section>

      <section>
        <title>The administrator profile</title>

        <para>The administrator profile has no restriction in the
        application.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Layering the application</title>

    <para>Now that we have collected the detailed specifications, it's time to
    feed the framework with them. As we saw before, most of the job will
    consist in describing the different layers in a structured way. But before
    going further, let's define the best practices regarding the logical
    layering of a typical Jspresso application (although these practices may
    generally apply to any well designed application). We will define 3
    logical layers from the bottom to the top :</para>

    <itemizedlist>
      <listitem>
        <para>The domain model</para>
      </listitem>

      <listitem>
        <para>The backend</para>
      </listitem>

      <listitem>
        <para>The frontend</para>
      </listitem>
    </itemizedlist>

    <para>This organisation will help to prevent cyclic dependencies between
    layers since each layer will be allowed to use lower ones but not higher
    ones (e.g. : the backend may use the domain model but not the
    frontend).</para>

    <para>Of course, this is a minimal logical layering. Each of this layer
    may be further divided in subparts depending on the software complexity.
    For instance the domain model might be divided in master and movement data
    and the backend and frontend may be divided in modules. It's entirely up
    to the application designer to tailor these rules. But it surely is the
    first design activity.</para>

    <para>The <link linkend="general-cod">general architecture diagram</link>
    introduces this layering strategy.</para>

    <figure id="general-cod">
      <title>General architecture diagram</title>

      <mediaobject>
        <imageobject>
          <imagedata contentdepth="60%" fileref="../uml/general-cod.PNG"
                     scalefit="1" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Let's define now what precisely go in these layers.</para>

    <section>
      <title>The domain model</title>

      <para>The domain model includes :</para>

      <itemizedlist>
        <listitem>
          <para>The entities. An entity will be described by :</para>

          <itemizedlist>
            <listitem>
              <para>properties along with their constraints and their
              interceptors</para>
            </listitem>

            <listitem>
              <para>behaviour (business methods, life-cycle
              interceptors)</para>
            </listitem>

            <listitem>
              <para>integrity enforcements</para>
            </listitem>

            <listitem>
              <para>default presentation elements (name, icon, rendered
              properties, ordering properties)</para>
            </listitem>

            <listitem>
              <para>relationships to other entities (cardinality,
              reversibility)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The components. A component has all the characteristics of an
          entity except that it is not autonomous since It is designed as a
          structure to be inlined in an entity (e.g. : an address
          structure).</para>
        </listitem>

        <listitem>
          <para>Other structural elements like common business
          interfaces.</para>
        </listitem>
      </itemizedlist>

      <para>We will see later that there virtually any domain model can be
      extensively described using Jspresso. This includes for instance
      polymorphic entities or associations, multiple inheritance, and so
      on.</para>
    </section>

    <section>
      <title>The backend</title>

      <para>The backend includes all the application parts that do not depend
      on the client :</para>

      <itemizedlist>
        <listitem>
          <para>The actions server parts (which interact with the domain model
          for instance)</para>
        </listitem>

        <listitem>
          <para>The application workspaces along with their hierarchy of
          modules. A workspace is a top application entry point which is
          directly accessible by the end user.</para>
        </listitem>

        <listitem>
          <para>The application modules. They form a hierarchy since modules
          may contain other modules. Each module is an independent application
          part targeted at accessing the backend data (domain model
          manipulation, reporting, ...).</para>
        </listitem>

        <listitem>
          <para>The backend controller which holds the user backend
          application state and its configuration (in-memory model
          state)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The frontend</title>

      <para>The frontend includes all the application parts that interact
      directly with the end-user :</para>

      <itemizedlist>
        <listitem>
          <para>The views</para>
        </listitem>

        <listitem>
          <para>The action client parts (which handle user interaction and
          trigger action server parts)</para>
        </listitem>

        <listitem>
          <para>The client application module parts</para>
        </listitem>

        <listitem>
          <para>The frontend controller which holds the user frontend
          application state and its configuration (workspaces and modules
          state)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Describing the domain model</title>

    <para>In this chapter, you will learn how to feed the Jspresso framework
    with the sample domain model description.</para>

    <section>
      <title>Using the "Sugar for Jspresso" DSL</title>

      <para>The preferred way of writing applications is to use the new
      Jspresso Groovy based DSL (Domain Specific Language) : "Sugar for
      Jspresso" - aka <emphasis role="bold">SJS</emphasis>. The SJS DSL was
      thought from the very begining to stay compatible with Spring XML which
      was the legacy language used in Jspresso. This means that during the
      build, the SJS authored files are "compiled" to generate Spring XML
      files that are loaded in the Spring context beside the legacy ones. So
      you can :</para>

      <itemizedlist>
        <listitem>
          <para>develop only using SJS.</para>
        </listitem>

        <listitem>
          <para>develop only using Spring XML.</para>
        </listitem>

        <listitem>
          <para>develop using SJS and Spring XML and even reference on one
          side, components that are defined on the other side.</para>
        </listitem>
      </itemizedlist>

      <para>For instance, describing your application model will be a matter
      of writing SJS code into the <filename>model.groovy</filename> file
      located here :</para>

      <blockquote>
        <para><filename>hrsample/core/src/main/dsl/model.groovy</filename></para>
      </blockquote>

      <para>Authoring SJS code is greatly simplified when using <ulink
      url="http://www.jspresso.org/page/jspresso-developer-studio">Jspresso
      Developer Studio</ulink>, so make sure you've correctly installed
      it.</para>

      <para>Here is what the default generated
      <filename>model.groovy</filename> looks like :</para>

      <programlisting language="xml">// Implement your domain here using the SJS DSL.
 </programlisting>

      <note>
        <para>For those who are familiar with Jspresso Spring XML, and want to
        migrate smoothly to SJS, you can always have a look to the SJS
        generated Spring config files. For instance,
        <filename>model.groovy</filename> will be translated into
        <filename>hrsample/core/target/generated-resources/dsl/org/jspresso/hrsample/model/dsl-model.xml</filename>
        by the SJS compiler.</para>
      </note>

      <para>In all example given using the SJS DSL, pay special attention to
      conventions. For instance, package names are most of the time inferred
      and you will rarely change the default. This feature makes SJS code much
      more compact and easier to read than plain Spring XML.</para>
    </section>

    <section>
      <title>Interfaces</title>

      <para>As a starting point, we will describe the <link
      linkend="commons-cd">commons</link> model part.</para>

      <para>The <code>Nameable</code> interface may be described as follow
      :</para>

      <para><programlisting language="groovy">Interface<co id="Nameable_1" /> ('Nameable'<co
            id="Nameable_2" />) {
  string_64<co id="Nameable_3" /> 'name'<co id="Nameable_4" />, mandatory:true<co
            id="Nameable_5" />
}</programlisting><calloutlist>
          <callout arearefs="Nameable_1">
            <para>Since we are describing a generic interface (which may or
            may not turn to be an entity) we will use an
            <code>Interface</code> keyword.</para>
          </callout>

          <callout arearefs="Nameable_2">
            <para>We name the interface
            <code><classname>Nameable</classname></code>. By convention, since
            we are in the <package>org.jspresso.hrsample</package> namespace,
            this will turn into a
            <classname>org.jspresso.hrsample.model.Nameable</classname>
            interface class.</para>
          </callout>

          <callout arearefs="Nameable_3">
            <para>We declare a <classname>String</classname> property, with a
            maximum length of 64 chars.</para>
          </callout>

          <callout arearefs="Nameable_4">
            <para>We name this property <code>name</code>, so that the
            corresponding <code>getName()</code> and
            <code>setName(String)</code> accessors will be generated.</para>
          </callout>

          <callout arearefs="Nameable_5">
            <para>We make this property mandatory.</para>
          </callout>
        </calloutlist></para>

      <para>As you can see above, we create an interface descriptor
      (<code>org.jspresso.hrsample.model.Nameable</code>) with one property
      (<code>name</code>) along with its constraints (<code>maxLength</code>
      and <code>mandatory</code>). This is a fairly simple interface since it
      has no intrinsic behaviour nor relationships with other
      components.</para>

      <para>So now, lets describe the <code>Traceable</code> interface as
      follow :</para>

      <para><programlisting language="groovy">Interface('Traceable',
          uncloned:['createTimestamp', 'lastUpdateTimestamp']<co
            id="Traceable_1" />) {
  date_time<co id="Traceable_2" /> 'createTimestamp', readOnly:true<co
            id="Traceable_3" />, timeZoneAware:true<co id="Traceable_4" />
  date_time 'lastUpdateTimestamp', readOnly:true, timeZoneAware:true
}</programlisting><calloutlist>
          <callout arearefs="Traceable_1">
            <para>Whenever an entity implementing the
            <classname>Traceable</classname> interface is cloned by Jspresso,
            the cloning process will ignore both tracing properties.</para>
          </callout>

          <callout arearefs="Traceable_2">
            <para>We declare a date property for which the time portion will
            be preserved.</para>
          </callout>

          <callout arearefs="Traceable_3">
            <para>The date property is made read-only, i.e. it will only be
            updated programatically.</para>
          </callout>

          <callout arearefs="Traceable_4">
            <para>The date property is a technical date, i.e. it is sensitive
            to the client / server timezones difference. It will translate
            differently depending on the client timezone.</para>
          </callout>
        </calloutlist>The <code>Traceable</code> interface description is
      slightly more complicated than the <code>Nameable</code> interface since
      not all properties are eligible to cloning
      (<code>uncloned</code>).</para>
    </section>

    <section>
      <title>Generating the domain model code</title>

      <para>It is time now to get our interfaces generated before going
      further. Let's use the Jspresso generation tool to make it
      happen.</para>

      <para>As we saw before the Jspresso build is completely integrated in
      Maven. This includes domain model code generation. You can trigger the
      build from an external terminal window or directly from the IDE using an
      maven Eclipse plugin. Navigate to your project root folder and type
      :</para>

      <blockquote>
        <para><code>mvn compile</code></para>
      </blockquote>

      <para><note>
          <para>If you want to speed up this generation phase, instead of
          launching <code>mvn compile</code> from the
          <filename>hrsample/</filename> root folder, you can lauch it from
          the <filename>hrsample/core/</filename> folder which is the project
          module that holds the domain model.</para>
        </note>Go back to Eclipse and refresh your project -
      <keycode>F5</keycode> - so that the generated java source is detected.
      You may now have a look to the following folder to see the generated
      java source files :</para>

      <blockquote>
        <para><filename>hrsample/core/target/generated-sources/entitygenerator/org/jspresso/hrsample/model</filename></para>
      </blockquote>

      <para>Alternatively you can directly use the Eclipse <quote>Open
      type</quote> function to Quickly navigate navigate to the generated
      <code>Nameable</code> and <code>Traceable</code> types.</para>

      <para><note>
          <para>Jpresso uses compile time generation of the domain model
          classes and resources. Generated artifacts always go into
          <filename>target/generated-xxx</filename> folders. You should never
          place any hand-written code in these generated source folders since
          they can be deleted at any time during a <code>maven clean</code>
          operation. Always use standard maven source folders
          (<filename>src/main/java</filename> and
          <filename>src/main/resources</filename>).</para>
        </note>You should have now the 2 generated classes :</para>

      <itemizedlist>
        <listitem>
          <para><filename>Nameable.java</filename> for the Nameable interface
          (see the <link linkend="Nameable">source code below</link>).</para>
        </listitem>

        <listitem>
          <para><filename>Traceable.java</filename> for the Traceable
          interface.</para>
        </listitem>
      </itemizedlist>

      <programlisting id="Nameable" language="java">package org.jspresso.hrsample.model;

/**
 * Nameable component.
 * &lt;p&gt;
 * Generated by Jspresso. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Jspresso
 */
public interface Nameable {

  /**
   * Gets the name.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "NAME"
   *           length = "64"
   *           not-null = "true"
   * @return the name.
   */
  java.lang.String getName();

  /**
   * Sets the name.
   *
   * @param name
   *          the name to set.
   */
  void setName(java.lang.String name);

}</programlisting>

      <para>These 2 java classes are actually java interfaces with getters and
      setters for the declared properties. In fact, you will never need any
      implementation for them since Jspresso will automatically handle their
      implementation for you at runtime using J2SE proxies. This approach
      relieves the developer from writing the implementation classes and thus,
      improves quality, robustness and productivity.</para>

      <para>You may also notice that the generator took care of annotating the
      classes with <ulink url="http://www.hibernate.org/">hibernate</ulink>
      <ulink
      url="http://xdoclet.sourceforge.net/xdoclet/index.html">xDoclet</ulink>
      attributes. They will be used later to generate the necessary
      persistence meta-data.</para>
    </section>

    <section>
      <title>Adding life-cycle behaviour</title>

      <para>What about the handling of the <code>Traceable</code> properties ?
      We want them to follow the life-cycle of any traceable entity, i.e.
      :</para>

      <itemizedlist>
        <listitem>
          <para>Set the <code>createTimestamp</code> when the entity is
          persisted for the first time.</para>
        </listitem>

        <listitem>
          <para>Set the <code>lastUpdateTimestamp</code> when the entity is
          updated in the persistent store.</para>
        </listitem>
      </itemizedlist>

      <para>It is time to write our first lines of java to achieve that.
      Navigate to the <filename>/hrsample/core/src/main/java</filename> source
      folder and create the life-cycle interceptor
      <code>org.jspresso.hrsample.model.service.TraceableLifecycleInterceptor</code>
      java class as follow :</para>

      <programlisting language="java">package org.jspresso.hrsample.model.service;

import java.util.Date;

import org.jspresso.hrsample.model.Traceable;
import org.jspresso.framework.model.component.service.EmptyLifecycleInterceptor;
import org.jspresso.framework.model.entity.IEntityFactory;
import org.jspresso.framework.model.entity.IEntityLifecycleHandler;
import org.jspresso.framework.security.UserPrincipal;

/**
 * Default lifecycle service for tracing.
 */
public class TraceableLifecycleInterceptor extends
    EmptyLifecycleInterceptor&lt;Traceable&gt; <co id="lcInterceptor" /> {

  /**
   * Sets the create timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  public boolean onPersist(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setCreateTimestamp(new Date()); <co id="onPersist" />
    return true; <co id="onPersistReturn" />
  }

  /**
   * Sets the last update timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  public boolean onUpdate(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setLastUpdateTimestamp(new Date()); <co id="onUpdate" />
    return true;
  }
}</programlisting>

      <calloutlist>
        <callout arearefs="lcInterceptor">
          <para>The class inherits from the support class
          <code>EmptyLifecycleInterceptor</code> which empty implements the
          required life-cycle interceptor interface
          <code>EmptyLifecycleInterceptor</code> as well as the marker
          interface <code>IComponentService</code>.</para>
        </callout>

        <callout arearefs="onPersist">
          <para>Whenever a <code>Traceable</code> component is persisted
          (saved for the first time), set its
          <code>createTimestamp</code>.</para>
        </callout>

        <callout arearefs="onPersistReturn">
          <para>Return true to notify the framework that the state of the
          component has been updated.</para>
        </callout>

        <callout arearefs="onUpdate">
          <para>Whenever a <code>Traceable</code> component is updated
          (subsequent saves), update its
          <code>lastUpdateTimestamp</code>.</para>
        </callout>
      </calloutlist>

      <para>We can now link the life-cycle interceptor to our
      <code>Traceable</code> interface bean descriptor as below :</para>

      <para><programlisting language="groovy">Interface('Traceable',
    <emphasis role="bold">interceptors:'TraceableLifecycleInterceptor'</emphasis><co
            id="TraceableLifecycleInterceptor_1" />,
    uncloned:['createTimestamp', 'lastUpdateTimestamp']) {
  ...
}</programlisting><calloutlist>
          <callout arearefs="TraceableLifecycleInterceptor_1">
            <para>Defines an ordered list of life-cycle interceptors attached
            to the component. Note that, by convention, we can ommit the
            package of the
            <classname>TraceableLifecycleInterceptor</classname> class, since
            it will be inferred from the current namespace.</para>
          </callout>
        </calloutlist></para>
    </section>

    <section>
      <title>Entities</title>

      <para>As of now, we have only dealt with interfaces which are not
      entities by themselves. Describing an entity follows the exact same
      process except that we make its descriptor an entity descriptor.</para>

      <para>So let's describe the <code>City</code> entity as below :</para>

      <para><programlisting language="groovy">Entity<co id="City_1" />('City',
       extend:'Nameable'<co id="City_2" />) {
  string_10 'zip'
}</programlisting><calloutlist>
          <callout arearefs="City_1">
            <para>We are now declaring a concrete entity, thus using the
            <code>Entity</code> keyword.</para>
          </callout>

          <callout arearefs="City_2">
            <para>We make the <code><classname>City</classname></code> entity
            inherit from the <code><classname>Nameable</classname></code>
            interface, so it will bring the name property.</para>
          </callout>
        </calloutlist></para>

      <para>the Jspresso Maven compilation will produce the following class
      (<filename>City.java</filename>) :</para>

      <programlisting language="java">package org.jspresso.hrsample.model;

/**
 * City entity.
 * &lt;p&gt;
 * Generated by Jspresso. All rights reserved.
 * &lt;p&gt;
 *
 * @hibernate.mapping
 *           default-access = "org.jspresso.framework.model.persistence\
 *                             .hibernate.property.EntityPropertyAccessor"
 * @hibernate.class
 *   table = "CITY"
 *   dynamic-insert = "true"
 *   dynamic-update = "true"
 *   persister = "org.jspresso.framework.model.persistence.hibernate.entity\
 *                .persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Jspresso
 */
public interface City extends
  org.jspresso.hrsample.model.Nameable,
  org.jspresso.framework.model.entity.IEntity <co id="IEntity" /> {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the zip.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ZIP"
   *           length = "10"
   * @return the zip.
   */
  java.lang.String getZip();

  /**
   * Sets the zip.
   *
   * @param zip
   *          the zip to set.
   */
  void setZip(java.lang.String zip);

}</programlisting>

      <calloutlist>
        <callout arearefs="IEntity">
          <para><code>City</code> is an entity so the generator made it
          inherit from <code>IEntity</code> which is a Jspresso framework base
          class.</para>
        </callout>
      </calloutlist>

      <para>You might notice that there are slightly more hibernate xDoclet
      tags (class level tags, id and version) to handle the entity persistence
      specifics. But as for <code>Nameable</code> and <code>Traceable</code>,
      the <code>City</code> entity is not more than an interface and its
      implementation will be completely handled by the framework.</para>
    </section>

    <section>
      <title>Components</title>

      <para>A component is a data structure which is intended to be inlined in
      other components or entities. Like entities and interfaces, you can
      define properties and behaviour in a component. A component cannot live
      by itself. It is an elegant mean to factor common data and behaviour
      into higher level model parts.</para>

      <para>So let's describe the <code>ContactInfo</code> component as below
      :</para>

      <para><programlisting language="groovy">Component<co id="ContactInfo_1" />('ContactInfo') {
  string_256 'address'
  string_32  'phone'
  string_128 'email', regex:"[\\w\\-\\.]*@[\\w\\-\\.]*"<co id="ContactInfo_2" />, regexSample:'contact@acme.com'<co
            id="ContactInfo_3" />
}</programlisting><calloutlist>
          <callout arearefs="ContactInfo_1">
            <para>Since <code>ContactInfo</code> is an component, we use a
            <code>Component</code> keyword.</para>
          </callout>

          <callout arearefs="ContactInfo_2">
            <para>This is a special kind of string constraint enforcement
            through a regular expression; we want an email to conform to
            contain the @ sign, be without space and be only composed of
            literals plus '.' and '-'.</para>
          </callout>

          <callout arearefs="ContactInfo_3">
            <para>Whenever there is some kind of communication to initiate (an
            invalid value for instance), this is an example of a correct
            value.</para>
          </callout>
        </calloutlist></para>

      <para>Relaunching the Jspresso generator will produce the following
      class (<filename>ContactInfo.java</filename>) :</para>

      <programlisting language="java">package org.jspresso.hrsample.model;

/**
 * ContactInfo component.
 * &lt;p&gt;
 * Generated by Jspresso. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Jspresso
 */
public interface ContactInfo extends
  org.jspresso.framework.model.component.IComponent <co id="IComponent" /> {

  /**
   * Gets the address.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ADDRESS"
   *           length = "256"
   * @return the address.
   */
  java.lang.String getAddress();

  /**
   * Sets the address.
   *
   * @param address
   *          the address to set.
   */
  void setAddress(java.lang.String address);

  /**
   * Gets the phone.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PHONE"
   *           length = "32"
   * @return the phone.
   */
  java.lang.String getPhone();

  /**
   * Sets the phone.
   *
   * @param phone
   *          the phone to set.
   */
  void setPhone(java.lang.String phone);

  /**
   * Gets the email.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "EMAIL"
   *           length = "128"
   * @return the email.
   */
  java.lang.String getEmail();

  /**
   * Sets the email.
   *
   * @param email
   *          the email to set.
   */
  void setEmail(java.lang.String email);

}</programlisting>

      <calloutlist>
        <callout arearefs="IComponent">
          <para><code>ContactInfo</code> is an entity so the generator made it
          inherit from <code>IComponent</code> which is a Jspresso framework
          base class.</para>
        </callout>
      </calloutlist>

      <para>You might have notice that the <code>ContactInfo</code> component
      is missing something : its relationship to the <code>City</code>
      entity.</para>
    </section>

    <section>
      <title>Unidirectional relationships</title>

      <para>It's time to link our first components together.</para>

      <section>
        <title>Unidirectional N-1 relationships</title>

        <para>Let's first deal with the simple unidirectional association
        <code>ContactInfo</code> -&gt; <code>City</code>. We are going to
        define a <code>city</code> property in the <code>ContactInfo</code>
        component.</para>

        <para>The following SJS fragment will do the trick :</para>

        <para><programlisting language="groovy">Component('ContactInfo') {
  ...
  <emphasis role="bold">reference 'city'</emphasis><co id="ContactInfo_ref_1" /><emphasis
              role="bold">, ref:'City'</emphasis><co id="ContactInfo_ref_2" />
  ...
}</programlisting><calloutlist>
            <callout arearefs="ContactInfo_ref_1">
              <para><code>ContactInfo</code> has a reference to the
              <code>City</code> entity so we describe this using a
              <code>reference</code> keyword.</para>
            </callout>

            <callout arearefs="ContactInfo_ref_2">
              <para>We link the reference property to the <code>City</code>
              entity we described above.</para>
            </callout>
          </calloutlist></para>

        <para>Relaunching the Maven compilation will update the
        <filename>ContactInfo.java</filename> source file we generated above,
        but since this is a unidirectional relationship, the
        <filename>City.java</filename> file will remain untouched. The
        following lines are added in the <filename>ContactInfo.java</filename>
        source file :</para>

        <para><programlisting language="java">  /**
   * Gets the city.
   *
   * @hibernate.many-to-one
   *           cascade = "persist,merge,save-update,refresh,evict,replicate"
   * @hibernate.column
   *           name = "CITY_ID"
   * @return the city.
   */
  org.jspresso.hrsample.model.City getCity();

  /**
   * Sets the city.
   *
   * @param city
   *          the city to set.
   */
  void setCity(org.jspresso.hrsample.model.City city);</programlisting>Again,
        the needed hibernate xDoclet tags are added to reflect the
        relationship between the component and the entity.</para>

        <para>To end with the commons model part, let's define the Event
        entity :</para>

        <para><programlisting language="groovy">Entity('Event',extend:'Traceable'<co
              id="Event_1" />){
  html<co id="Event_2" /> 'text', maxLength:2048 , id:'Event-text'<co
              id="Event_3" />
}</programlisting><calloutlist>
            <callout arearefs="Event_1">
              <para>An event is a <code>Traceable</code> entity.</para>
            </callout>

            <callout arearefs="Event_2">
              <para>We use a <code>html</code> property instead of a
              <code>string</code> one. This is to inform the framework that
              this property is used to store HTML formatted data; although
              there is no direct impact on the model layer (it is still stored
              as a <code>String</code>), it might be useful in the view layer
              (e.g. : use a rich text area instead of a text field to display
              and edit the <code>Event</code> text property).</para>
            </callout>

            <callout arearefs="Event_3">
              <para>We assign explicitely an id to the <code>text</code>
              property. This is to be able to reference it individually from
              another layer (e.g. the view layer). By default, only reference
              and collection properties are implicitly assigned an id in the
              form <code>Owner-property</code>. We kept this convention to
              declare an id on the text property.</para>
            </callout>
          </calloutlist></para>

        <para>This first relationship is fairly simple since it is a n-1
        unidirectional association. Of course, the Jspresso can also
        seamlessly handle 1-n, 1-1 and n-n unidirectional and bi-directional
        associations and compositions (strong aggregations).</para>

        <para>Now that we are done with the commons model part, let's see how
        we can handle the employees model part.</para>
      </section>

      <section>
        <title>Inlined components</title>

        <para>The <code>Employee</code> entity is fairly simple to describe
        giving what we already achieved.</para>

        <para>Let's look at the SJS code below :</para>

        <para><programlisting language="groovy">Entity ('Employee',
        extend:['Nameable','Traceable']) {
  string_32 'firstName', mandatory:true
  string_10 'ssn', regex:'[\\d]{10}'<co id="Employee_1" />, regexSample:'0123456789', unicityScope:'empSsn'<co
              id="Employee_2" />
  date<co id="Employee_3" /> 'birthDate'
  date 'hireDate'
  enumeration<co id="Employee_4" /> 'gender', enumName:'GENDER', mandatory:true, valuesAndIcons<co
              id="Employee_5" />:[
              'M':'male-48x48.png',
              'F':'female-48x48.png']
  color<co id="Employee_6" /> 'preferredColor'
  bool<co id="Employee_7" /> 'married'
  decimal<co id="Employee_8" /> 'salary', minValue:0
  binary<co id="Employee_9" /> 'photo', maxLength:1048576, id:'Employee-photo',
         fileFilter:['images':['.jpg']],
         fileName:'photo.jpg'
  password<co id="Employee_10" /> 'password', maxLength:32
  reference<co id="Employee_11" /> 'contact', ref:'ContactInfo', id:'contact'
}</programlisting><calloutlist>
            <callout arearefs="Employee_1">
              <para>We defined a regular expression control on the ssn
              property since it must be composed of 10 and only 10
              digits.</para>
            </callout>

            <callout arearefs="Employee_2">
              <para>We define a unicity domain for the <code>ssn</code>
              property. This will translate in a unique key definition in the
              persistent store.</para>
            </callout>

            <callout arearefs="Employee_3">
              <para>We don't care about the time information of this date; so
              we use a <code>date</code> keyword as opposed to the
              <code>date_time</code> keyword that we used for the
              <code>Traceable</code> interface.</para>
            </callout>

            <callout arearefs="Employee_4">
              <para>This is a new type of property. This one defines a finite
              choice of values.</para>
            </callout>

            <callout arearefs="Employee_5">
              <para>We define each of the values composing the choice for the
              gender enumeration (either 'M' or 'F') along with icons if
              available.</para>
            </callout>

            <callout arearefs="Employee_6">
              <para>This defines a color property. Color properties are
              internally stored as their RGBA base 16 encoded value, but are
              visualized and edited using a color chooser un the UI.</para>
            </callout>

            <callout arearefs="Employee_7">
              <para>This defines a boolean property.</para>
            </callout>

            <callout arearefs="Employee_8">
              <para>This defines a decimal property.</para>
            </callout>

            <callout arearefs="Employee_9">
              <para>This defines a binary property. It comes with a file
              filter to set up the file extensions that are to be configured
              when the user chooses a file to upload in order to fill in this
              property value as well as a default filename that is used
              whensaving the property content to a file.</para>
            </callout>

            <callout arearefs="Employee_10">
              <para>This defines a password property. It is stored internally
              as a string but is visually represented using a password
              field.</para>
            </callout>

            <callout arearefs="Employee_11">
              <para>This is where we reference the <code>ContactInfo</code>
              component.</para>
            </callout>
          </calloutlist></para>

        <para>The employee description above shows that it is strictly
        equivalent - as far as description is concerned - to reference an
        entity or to inline a component (see the contact reference). The
        difference will be in the persistence store and in the views since an
        inlined component will have its attributes "merged" with the enclosing
        component as if they belonged to it.</para>
      </section>

      <section>
        <title>Unidirectional 1-N relationships</title>

        <para>You have surely noticed that we did not describe the 1-N
        composition between <code>Employee</code> and <code>Event</code>. This
        will be our first collection property and its description is actually
        quite straightforward :</para>

        <para>And the SJS way (note that SJS will automatically generate a
        top-level bean for the collection property, with an id in the form of
        <emphasis>Owner-property</emphasis>, i.e.
        <emphasis>Employee-events</emphasis>) :<programlisting
        language="groovy">Entity ('Employee'...) {
  ...
  list<co id="Employee-events_1" /> 'events', composition:true<co
              id="Employee-events_2" />, ref:'Event'<co id="Employee-events_3" />
  ...
}</programlisting><calloutlist>
            <callout arearefs="Employee-events_1">
              <para>We are describing a collection relationship property.
              Since we want an arbitrary, persistent, order using an index, we
              declare it as a <code>list</code>. If we didn't want to actually
              persist an arbitrary order (which is the vast majority of the
              cases), we would have used a <code>set</code> semantic using the
              <code>set</code> keyword.</para>
            </callout>

            <callout arearefs="Employee-events_2">
              <para>We make this relationship a composition to express the
              fact that whenever an employee is deleted, the attached events
              must also be deleted.</para>
            </callout>

            <callout arearefs="Employee-events_3">
              <para>Our collection property lists events; so we reference the
              <code>Event</code> entity as being the element type of our
              collection.</para>
            </callout>
          </calloutlist></para>

        <note>
          <para>SJS automatically generates an automatic id for collection
          properties and for reference properties. The generated id has the
          form of <emphasis>Owner-property</emphasis>, i.e.
          <emphasis>Employee-events</emphasis></para>
        </note>

        <para>Launching the Jspresso generator will generate the
        <filename>Employee.java</filename> source file :</para>

        <para><programlisting language="java">package org.jspresso.hrsample.model;

/**
 * Employee entity.
 * &lt;p&gt;
 * Generated by Jspresso. All rights reserved.
 * &lt;p&gt;
 *
 * @hibernate.mapping default-access =
 *                    "org.jspresso.framework.model.persistence\
 *                     .hibernate.property.EntityPropertyAccessor"
 * @hibernate.class table = "EMPLOYEE"
 *   dynamic-insert = "true"
 *   dynamic-update = "true"
 *   persister = "org.jspresso.framework.model.persistence.hibernate.entity\
 *                .persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Jspresso
 */
public interface Employee extends org.jspresso.hrsample.model.Nameable,
    org.jspresso.hrsample.model.Traceable,
    org.jspresso.framework.model.entity.IEntity {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   *               &lt;p&gt;
   *               {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   *                    &lt;p&gt;
   *                    {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the firstName.
   *
   * @hibernate.property
   * @hibernate.column name = "FIRST_NAME" length = "32"
   * @return the firstName.
   */
  java.lang.String getFirstName();

  /**
   * Sets the firstName.
   *
   * @param firstName
   *            the firstName to set.
   */
  void setFirstName(java.lang.String firstName);

  /**
   * Gets the ssn.
   *
   * @hibernate.property
   * @hibernate.column name = "SSN" length = "10" unique-key = "EMP_SSN_UNQ"
   * @return the ssn.
   */
  java.lang.String getSsn();

  /**
   * Sets the ssn.
   *
   * @param ssn
   *            the ssn to set.
   */
  void setSsn(java.lang.String ssn);

  /**
   * Gets the birthDate.
   *
   * @hibernate.property type = "date"
   * @hibernate.column name = "BIRTH_DATE"
   * @return the birthDate.
   */
  java.util.Date getBirthDate();

  /**
   * Sets the birthDate.
   *
   * @param birthDate
   *            the birthDate to set.
   */
  void setBirthDate(java.util.Date birthDate);

  /**
   * Gets the hireDate.
   *
   * @hibernate.property type = "date"
   * @hibernate.column name = "HIRE_DATE"
   * @return the hireDate.
   */
  java.util.Date getHireDate();

  /**
   * Sets the hireDate.
   *
   * @param hireDate
   *            the hireDate to set.
   */
  void setHireDate(java.util.Date hireDate);

  /**
   * Gets the gender.
   *
   * @hibernate.property
   * @hibernate.column name = "GENDER" length = "1" not-null = "true"
   * @return the gender.
   */
  java.lang.String getGender();

  /**
   * Sets the gender.
   *
   * @param gender
   *            the gender to set.
   */
  void setGender(java.lang.String gender);

  /**
   * Gets the contact.
   *
   * @hibernate.component prefix = "CONTACT_"
   * @return the contact.
   */
  org.jspresso.hrsample.model.ContactInfo getContact();

  /**
   * Gets the preferredColor.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PREFERRED_COLOR"
   *           length = "10"
   * @return the preferredColor.
   */
  java.lang.String getPreferredColor();

  /**
   * Sets the preferredColor.
   *
   * @param preferredColor
   *          the preferredColor to set.
   */
  void setPreferredColor(java.lang.String preferredColor);

  /**
   * Gets the married.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "MARRIED"
   *           not-null = "true"
   * @return the married.
   */
  boolean isMarried();

  /**
   * Sets the married.
   *
   * @param married
   *          the married to set.
   */
  void setMarried(boolean married);

  /**
   * Gets the salary.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "SALARY"
   *           precision = "10"
   *           scale = "2"
   * @return the salary.
   */
  java.math.BigDecimal getSalary();

  /**
   * Sets the salary.
   *
   * @param salary
   *          the salary to set.
   */
  void setSalary(java.math.BigDecimal salary);

  /**
   * Gets the photo.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PHOTO"
   *           length = "1048576"
   * @return the photo.
   */
  byte[] getPhoto();

  /**
   * Sets the photo.
   *
   * @param photo
   *          the photo to set.
   */
  void setPhoto(byte[] photo);

  /**
   * Gets the password.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PASSWORD"
   *           length = "32"
   * @return the password.
   */
  java.lang.String getPassword();

  /**
   * Sets the password.
   *
   * @param password
   *          the password to set.
   */
  void setPassword(java.lang.String password);

  /**
   * Sets the contact.
   *
   * @param contact
   *            the contact to set.
   */
  void setContact(org.jspresso.hrsample.model.ContactInfo contact);

  /**
   * Gets the events.
   *
   * @hibernate.list cascade =
   *                 "persist,merge,save-update,refresh,evict,replicate,delete"
   * @hibernate.key column = "EVENTS_EMPLOYEE_ID"
   * @hibernate.one-to-many class = "org.jspresso.hrsample.model.Event"
   * @hibernate.list-index column = "EVENTS_SEQ"
   * @return the events.
   */
  java.util.List&lt;org.jspresso.hrsample.model.Event&gt; getEvents();

  /**
   * Sets the events.
   *
   * @param events
   *            the events to set.
   */
  void setEvents(java.util.List&lt;org.jspresso.hrsample.model.Event&gt; events);

  /**
   * Adds an element to the events.
   *
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(org.jspresso.hrsample.model.Event eventsElement);

  /**
   * Adds an element to the events at the specified index. If the index is out
   * of the list bounds, the element is simply added at the end of the list.
   *
   * @param index
   *            the index to add the events element at.
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(int index,
      org.jspresso.hrsample.model.Event eventsElement);

  /**
   * Removes an element from the events.
   *
   * @param eventsElement
   *            the events element to remove.
   */
  void removeFromEvents(org.jspresso.hrsample.model.Event eventsElement);

}</programlisting>As you can see above, the generator has generated all the
        accessors for the events list property. If the events property had
        been designed as a set instead of a list, the adder using the index
        would not have been generated and the get/set pair would of course
        have used a <code>java.util.Set</code> instead of a
        <code>java.util.List</code>.</para>

        <para>Now that the employees model part is complete, let's deal with
        the organization.</para>
      </section>
    </section>

    <section>
      <title>Entity inheritance</title>

      <para>The organization model part is the most complex of the example,
      since it involves entity inheritance (and polymorphism) and other kinds
      of relationships (1-1, bi-directional). So let's begin with the entity
      inheritance graph and we will deal with their relationships next
      :</para>

      <para><programlisting language="groovy">Entity('Company',
       extend:['Nameable', 'Traceable']) {
  reference 'contact', ref:'ContactInfo'
}

Entity('OrganizationalUnit',
       extend:['Nameable', 'Traceable'],
       purelyAbstract:true<co id="OrganizationalUnit_1" />) {
  string_6 'ouId', regex:"[A-Z]{2}-[\\d]{3}", regexSample:'AB-123', mandatory:true
  reference 'contact', ref:'ContactInfo'
}

Entity('Department',
       extend:'OrganizationalUnit'<co id="OrganizationalUnit_2" />)

Entity('Team',
       extend:['OrganizationalUnit'])</programlisting><calloutlist>
          <callout arearefs="OrganizationalUnit_1">
            <para>An <code>OrganizationalUnit</code> will never be
            instantiated as such; only sub-entities will. This is why we
            define the entity as purely abstract.</para>
          </callout>

          <callout arearefs="OrganizationalUnit_2">
            <para><code>Department</code> inherits from
            <code>OrganizationalUnit</code> as do <code>Team</code>.</para>
          </callout>
        </calloutlist></para>

      <para>Pretty easy, no ? You describe entity inheritance exactly as you
      did previously for the interfaces. You don't have to care for anything
      else, the framework will handle it behind the scene for you.</para>

      <para>You can see also that <code>Company</code>,
      <code>OrganizationalUnit</code>, and <code>Employee</code> have the same
      contact property as an inlined <code>ContactInfo</code> component. It is
      a perfect candidate for factoring. So we can make the contact property
      descriptor a top level reference, name it contact and reference it in
      the 3 entities above. The result will be :</para>

      <para><programlisting language="groovy">Entity('Employee'...) {
  ...
  reference 'contact', ref:'ContactInfo', <emphasis role="bold">id:'contact'</emphasis><co
            id="contact_1" />
  ...
}

Entity('Company'...) {
  ...
  <emphasis role="bold">refId 'contact', id: 'contact'</emphasis><co id="contact_2" />
  ...
}

Entity('OrganizationalUnit'...) {
  ...
  <emphasis role="bold">refId 'contact', id: 'contact'</emphasis><co id="contact_3" />
  ...
}</programlisting><calloutlist>
          <callout arearefs="contact_1">
            <para>We factor the contact property in a top level referenceable
            element named "contact".</para>
          </callout>

          <callout arearefs="contact_2">
            <para>We reference the contact bean as a property of the
            <code>Company</code> entity</para>
          </callout>

          <callout arearefs="contact_3">
            <para>We reference the contact bean as a property of the
            <code>OrganizationalUnit</code> abstract entity.</para>
          </callout>
        </calloutlist></para>

      <para>Now that we have described our organization entities, let's link
      them together using relationships.</para>
    </section>

    <section>
      <title>Bi-directional relationships</title>

      <para>It is time see how the Jspresso framework handles relationships
      that are navigable at both ends.</para>

      <section>
        <title>Bi-directional 1-N relationships</title>

        <para>We are going to describe the <code>Company</code> &lt;-&gt;
        <code>Department</code> bi-directional 1-N relationship. To achieve
        that, we will first describe the N side of this composition, making it
        a top-level, referenceable bean and then make this N side the reverse
        end of the 1 side of the composition. This is achieved using the
        following SJS fragment :</para>

        <para><programlisting language="groovy">Entity('Company'...) {
  ...
  set 'departments', composition:true, ref:'Department'<co
              id="Company-departments_1" />
}

Entity('Department'...) {
  ...
  reference 'company', ref:'Company', <emphasis role="bold">reverse:'Company-departments'</emphasis><co
              id="Company-departments_2" />, mandatory:true
}</programlisting><calloutlist>
            <callout arearefs="Company-departments_1">
              <para>Like we did before for the employee <code>events</code>,
              we describe collection property for the company
              <code>departments</code>. This time, the collection property has
              a set semantic.</para>
            </callout>

            <callout arearefs="Company-departments_2">
              <para>We link both side of the <code>Company</code> &lt;-&gt;
              <code>Department</code> relationship assigning 1 side reverse of
              the other.</para>
            </callout>
          </calloutlist></para>

        <para>So making a relationship bi-directional is quite
        straightforward. We just have to reference one end of the relationship
        in the other end as being the reverse end. Although the generated java
        code will not be directly impacted by making a relationship
        bi-directional, hibernate xDoclet tags will be. More important is the
        impact on how the framework will handle the relationship updates
        behind the scene for you.</para>

        <para>Making the <code>Company</code> &lt;-&gt;
        <code>Department</code> relationship bi-directional implies the
        following on the <code>Company</code> side:</para>

        <para><orderedlist>
            <listitem>
              <para>Whenever a department is added to a company through the
              <code>addToDepartments(Department)</code> adder, the passed-in
              department will have its company property updated accordingly.
              In the (unexpected) case that the department was part of another
              company, it will be removed from its previous company
              departments before being added to the new one.</para>
            </listitem>

            <listitem>
              <para>Whenever a set of departments set as the company
              departments through the
              <code>setDepartments(Set&lt;Department&gt;)</code> setter, all
              the passed-in departments will have their company property
              updated accordingly. In the (unexpected) case that the
              departments were part of other companies, they will be removed
              from their previous respective company departments before being
              added to the new one. Moreover, all existing departments in the
              company before the update will have their company property
              reset.</para>
            </listitem>

            <listitem>
              <para>Whenever a department is removed from a company through
              the <code>removeFromDepartments(Department)</code> remover, the
              passed-in department will have its company property reset to
              <code>null</code>. In the (unexpected) case that the department
              was part of another company, it will be removed from its
              previous company departments.</para>
            </listitem>
          </orderedlist>And on the <code>Department</code> side :</para>

        <orderedlist>
          <listitem>
            <para>Whenever a company is set in a department through the
            <code>setCompany(Company)</code>, the company departments is
            updated accordingly. In the case that the passed-in company is
            <code>null</code>, the department will just be removed from its
            previous company if any.</para>
          </listitem>
        </orderedlist>

        <para>As you can see above, you can expect the Jspresso framework to
        extensively and transparently manage any bi-directional relationship
        for you. Just call whatever accessor you want and the domain model
        will be updated consistently.</para>

        <para>We describe the <code>Department</code> &lt;-&gt;
        <code>Team</code> relationship the same way :<programlisting
        language="groovy">Entity('Department'...) {
  ...
  set 'teams', composition:true, ref:'Team'
}

Entity('Team'...) {
  reference 'department', ref:'Department', reverse:'Department-teams', mandatory:true
}</programlisting></para>

        <para>And, to be complete, the <code>Company</code> &lt;-&gt;
        <code>Employees</code> relationship :</para>

        <para><programlisting language="groovy">Entity('Company'...) {
  ...
  set 'employees', composition:true, ref:'Employee'
}

Entity('Employee'...) {
  reference 'company', ref:'Company', reverse:'Company-employees', mandatory:true
}</programlisting></para>
      </section>

      <section>
        <title>Bi-directional 1-1 relationships</title>

        <para>The next type of relationship we will handle in the HR
        application is the 1-1 <code>OrganizationalUnit</code> &lt;-&gt;
        <code>Employee</code> manager association. And you have certainly
        already guessed that it is the exact same way to describe
        bi-directional 1-1 relationships than 1-N relationships except that
        both ends are reference property descriptors :</para>

        <para><programlisting language="groovy">Entity('Employee'...) {
  ...
  reference 'managedOu', ref:'OrganizationalUnit', <emphasis role="bold">reverse:'OrganizationalUnit-manager'</emphasis>
}

Entity('OrganizationalUnit'...) {
  ...
  reference 'manager', ref:'Employee'
}</programlisting></para>

        <para>Of course, setting one end of the 1-1 relationship will also
        update the other end accordingly without having to take care of
        it.</para>
      </section>

      <section>
        <title>Bi-directional N-N relationships</title>

        <para>Certainly one of the most difficult relationship to handle in
        business software development is the N-N relationship navigable at
        both ends. Here again, Jspresso handles all the complex plumbing for
        you. All you need to do is to declare both ends of the relationship as
        being a collection property descriptor. The following SJS fragment
        illustrates this for the <code>Team</code> &lt;-&gt;
        <code>Employee</code> relationship :</para>

        <para><programlisting language="groovy">Entity('Employee'...) {
  ...
  set 'teams', ref:'Team'
}

Entity('Team'...) {
  ...
  set 'members', ref:'Employee', <emphasis role="bold">reverse:'Employee-teams'</emphasis>
}</programlisting></para>

        <para>Of course, when re-generating the entities code,
        <code>Employee</code> and <code>Team</code> will have the
        corresponding collection accessors generated and whenever one side of
        the relationship is updated, the other one will also reflect the
        change.</para>
      </section>
    </section>

    <section>
      <title>Component services</title>

      <para>As of now, we have only dealt with Jspresso component properties.
      There might be situations where you want (or you need) your domain model
      components to implement arbitrary interfaces (maybe legacy interfaces)
      and provide an arbitrary implementation for them. The Jspresso framework
      supports it at any level of the domain model. As an example, let's
      consider the <code>EmployeeService</code> interface that we want all of
      our employee components to implement. This service provides one method
      to compute age based on a birth date passed as parameter. Whenever the
      passed-in date is null, the returned age will also be.</para>

      <para>Let's see how we can attach this service :</para>

      <para><programlisting language="groovy">Entity('Employee',
       ...
       services<co id="Employee-services_1" />:[EmployeeService<co
            id="Employee-services_2" />:'EmployeeServiceDelegate<co
            id="Employee-services_3" />']) {
  ...
}</programlisting><calloutlist>
          <callout arearefs="Employee-services_1">
            <para>We declare the services and their implementations attached
            to the <code>Employee</code> entity.</para>
          </callout>

          <callout arearefs="Employee-services_2">
            <para>By convention, the interface <code>EmployeeService</code>
            belongs to a package deduced from the namespace, i.e.
            <classname>org.jspresso.hrsample.model.service.EmployeeService</classname>.</para>
          </callout>

          <callout arearefs="Employee-services_3">
            <para>By convention, the implementation
            <code>EmployeeServiceDelegate</code> belongs to a package deduced
            from the namespace, i.e.
            <classname>org.jspresso.hrsample.model.service.EmployeeServiceDelegate</classname>.</para>
          </callout>
        </calloutlist></para>

      <para>Here is the <filename>EmployeeService.java</filename> source file
      :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.model.service;

import java.util.Date;

/**
 * Services offered by the Employee entity.
 */
public interface EmployeeService {

  /**
   * Computes the employee age.
   *
   * @param birthDate
   *            the employee birth date.
   * @return the computed age based on the birth date or null if the birt date
   *         is not available.
   */
  Integer computeAge(Date birthDate);
}</programlisting>And the <filename>EmployeeServiceDelegate.java</filename>
      source file :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.model.service;

import java.util.Date;

import org.jspresso.hrsample.model.Employee;
import org.jspresso.framework.model.component.service.IComponentService;

/**
 * The services delegate of the Employee entity
 */
public class EmployeeServiceDelegate implements IComponentService { <co
            id="IComponentService" />

  /**
   * Computes the employee age.
   *
   * @param employee
   *            the employee this service execution has been triggered on.
   * @param birthDate
   *            a birth date (might be different than the actual employee birth
   *            date).
   * @return the age computed from the birth date passed as parameter.
   */
  public Integer computeAge(Employee employee, Date birthDate) { <co
            id="fomatName" />
    if (birthDate != null) {
      return new Integer(
          (int) ((new Date().getTime() - birthDate.getTime()) / (1000L * 60 * 60 * 24 * 365)));
    }
    return null;
  }
}</programlisting><calloutlist>
          <callout arearefs="IComponentService">
            <para>We mark the delegate as implementing
            <code>IComponentService</code>.</para>
          </callout>

          <callout arearefs="fomatName">
            <para>We declare the method with the same name than the service
            method. The parameter list is the same than the service method
            with the target component instance to trigger the service on
            inserted at the beginning of the list.</para>
          </callout>
        </calloutlist>You will notice that
      <code>EmployeeServiceDelegate</code> does not itself implements
      <code>EmployeeService</code>. This is simply because although the names
      of the implemented methods must match, their signature is augmented by
      the component instance to work on. This allows the Jspresso framework to
      share services delegates across multiple component instances.</para>

      <para>A re-generation of the <filename>Employee.java</filename> source
      updates the <code>Employee</code> definition so that it now implements
      the <code>EmployeeService</code> interface :</para>

      <para><programlisting language="java">...
public interface Employee extends
  org.jspresso.hrsample.model.Nameable,
  org.jspresso.hrsample.model.Traceable,
  org.jspresso.framework.model.entity.IEntity,
  org.jspresso.hrsample.model.service.EmployeeService {
...
}</programlisting>Again, Jspresso will seamlessly take care of triggering the
      delegates' methods, passing the right parameters, whenever the service
      is requested on the target component.</para>
    </section>

    <section>
      <title>Computed properties</title>

      <para>Not all properties have a representation in the persistent store.
      Some of them may be computed using other parts of the domain model. For
      instance, in the <code>Employee</code> entity, the age property is one
      of them. It is fairly easy to compute the age of an employee from his
      birth date and this is the service we have just implemented above. Of
      course computed properties are not limited to entities. They can be
      declared on any Jspresso managed component (inlined components,
      interfaces and entities). And they are not limited to scalar properties.
      Even a collection property or a reference property may be computed this
      way.</para>

      <para>Let's see how we can link it using Jspresso :</para>

      <para><programlisting language="groovy">Entity('Employee',
       ...
       <emphasis role="bold">extension :'EmployeeExtension'</emphasis><co
            id="EmployeeExtension_1" />) {
  ...
  integer 'age', minValue:0, maxValue:150, readOnly:true, <emphasis
            role="bold">computed:true</emphasis><co id="EmployeeExtension_2" />
}</programlisting><calloutlist>
          <callout arearefs="EmployeeExtension_1">
            <para>We declare the <code>EmployeeExtension</code> delegate
            class. The extension package is determined by convention from the
            namespace, i.e.
            <classname>org.jspresso.hrsample.model.extension.EmployeeExtension</classname>.</para>
          </callout>

          <callout arearefs="EmployeeExtension_2">
            <para>We declare the <code>age</code> property as being computed
            by the extension.</para>
          </callout>
        </calloutlist></para>

      <para>As you can see in the above fragment, the age property is almost
      described like any other standard entity property. What differs is the
      reference to the
      <code>org.jspresso.hrsample.model.extension.EmployeeExtension</code>
      java class that will be used to compute it. So let's code it :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.model.extension;

import org.jspresso.hrsample.model.Employee;
import org.jspresso.framework.model.component.AbstractComponentExtension;

/**
 * Helper class computing extended properties for Employee entity.
 */
public class EmployeeExtension extends
    AbstractComponentExtension&lt;Employee&gt; <co
            id="AbstractComponentExtension" /> {

  /**
   * Constructs a new &lt;code&gt;EmployeeExtension&lt;/code&gt; instance.
   *
   * @param extendedEmployee
   *            The extended employee instance.
   */
  public EmployeeExtension(Employee extendedEmployee) {
    super(extendedEmployee);
  }

  /**
   * Computes the employee age.
   *
   * @return The employee age.
   */
  public Integer getAge() { <co id="getAge" />
    return getComponent()<co id="getComponent" />.computeAge<co
            id="computeAge" />(getComponent().getBirthDate());
  }
}</programlisting><calloutlist>
          <callout arearefs="AbstractComponentExtension">
            <para>The employee extension class inherit from the
            <code>AbstractComponentExtension</code> framework base
            class.</para>
          </callout>

          <callout arearefs="getAge">
            <para>We implement the <code>getAge()</code> method which is
            triggered by the framework whenever the age property is accessed
            on an employee.</para>
          </callout>

          <callout arearefs="getComponent">
            <para>Note the use of the <code>getComponent()</code> method to
            retrieve the instance of employee this extension is attached to.
            This will be the starting point for exploring the domain model and
            computing arbitrary complex attributes.</para>
          </callout>

          <callout arearefs="computeAge">
            <para>We call the service method we have implemented in the
            previous chapter.</para>
          </callout>
        </calloutlist>Implementing the employee extension class as above is
      plainly licit but might lead to performance issues for more complex
      computations. In fact, each time the age property is requested, the
      <code>getAge()</code> method is triggered. This is not painful for the
      simple age implementation but imagine that you had to do a CPU or
      network consuming computation to return the computed property !</para>

      <para>Moreover, whenever the birth date is modified, no one is notified
      that the age changes since we did not implement anywhere the dependency
      "birth date ⇒ age".</para>

      <para>Pushing the analysis further shows that the age of an employee
      does not change until his birth date changes (which is very unlikely).
      So a more efficient implementation for the employee extension class
      consist in keeping the computed age value for later use and listening to
      changes of the birth date property to invalidate the age cached value.
      Hopefully, the implementation is almost straightforward since every
      Jspresso managed component can be listened to for property
      changes.</para>

      <para>The following update of the <filename>Employee.java</filename>
      source file fixes the 2 caveats described above :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.model.extension;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import org.jspresso.hrsample.model.Employee;
import org.jspresso.framework.model.component.AbstractComponentExtension;
import org.jspresso.framework.util.bean.IPropertyChangeCapable;

/**
 * Helper class computing extended properties for Employee entity.
 */
public class EmployeeExtension extends AbstractComponentExtension&lt;Employee&gt; {

  private Integer age = null; <co id="age" />

  /**
   * Constructs a new &lt;code&gt;EmployeeExtension&lt;/code&gt; instance.
   *
   * @param extendedEmployee
   *            The extended Employee instance.
   */
  public EmployeeExtension(Employee extendedEmployee) {
    super(extendedEmployee);
    extendedEmployee.addPropertyChangeListener("birthDate", <co
            id="addPropertyChangeListener" />
        new PropertyChangeListener() {

          public void propertyChange(PropertyChangeEvent evt) {
            Integer oldAge = age;
            age = null; <co id="ageReset" />
            getComponent().firePropertyChange("age", oldAge,
                IPropertyChangeCapable.UNKNOWN); <co id="firePropertyChange" />
          }
        });
  }

  /**
   * Computes the employee age.
   *
   * @return The employee age.
   */
  public Integer getAge() {
    if (age != null) {
      return age; <co id="returnAge" />
    }
    age = getComponent().computeAge(getComponent().getBirthDate());
    return age;
  }
}</programlisting></para>

      <para><calloutlist>
          <callout arearefs="age">
            <para>The age cache attribute.</para>
          </callout>

          <callout arearefs="addPropertyChangeListener">
            <para>We attach to the birth date property to be notified of a
            change.</para>
          </callout>

          <callout arearefs="ageReset">
            <para>Whenever the birth date changes, we invalidate the age
            cache.</para>
          </callout>

          <callout arearefs="firePropertyChange">
            <para>And we notify listeners, if any, of the age property change.
            Note the use of the <code>UNKNOWN</code> constant. This is to
            avoid useless computations if there is no listener attached to the
            age property; the computation will only be triggered when the age
            property is actually requested.</para>
          </callout>

          <callout arearefs="returnAge">
            <para>Whenever the age cache is valid, return it. If it has not
            been computed yet or if the cache has just been invalidated,
            perform the computation.</para>
          </callout>
        </calloutlist>When re-generating the
      <filename>Employee.java</filename> source file, you will notice that the
      <code>getAge()</code> method will be added but without any hibernate
      xDoclet annotation since the age property is not related to the
      <code>Employee</code> persistence. Once again, the framework will
      completely take care of calling the delegate class whenever the age
      property is requested.</para>

      <para>The key advantages of this type of modularization are :</para>

      <itemizedlist>
        <listitem>
          <para>Easy switching between implementations. You might have a mock
          implementation for the early stage of the development and when the
          job is done, switch with the real one. You could also switch the
          implementations depending on the environment you deploy to.</para>
        </listitem>

        <listitem>
          <para>Clear separation of concerns allowing an efficient
          distribution of work between developers.</para>
        </listitem>

        <listitem>
          <para>Ease of monitoring and testing. The code responsible of the
          implementation can be easily instrumented.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Property processors</title>

      <para>A clean and efficient domain model design assigns to the business
      objects the responsibility of maintaining their integrity.</para>

      <para>This implies :</para>

      <orderedlist>
        <listitem>
          <para>Checking a property before it gets actually modified. Trying
          to set a value that would compromise the business object integrity
          must be prevented and should raise a clear notification.</para>
        </listitem>

        <listitem>
          <para>Being able to intercept a setter to change the value actually
          set (e.g. ensuring a string is uppercase).</para>
        </listitem>

        <listitem>
          <para>Triggering some extra computation when a property value gets
          actually updated.</para>
        </listitem>
      </orderedlist>

      <para>The first point is partially covered by some of the constraints
      that can be assigned on the property descriptors; assigning a maximum
      value to an integer property descriptor or a regular expression to a
      string property descriptor are such controls. Unfortunately, there are
      situations when these type of controls are not enough because, for
      instance, the integrity of the component is checked against its global
      state (a property value is constrained by the values of other properties
      of the business object or even of other business objects of the
      model).</para>

      <para>As far as the second and third points are concerned, we have seen
      nothing yet that would help to cover it.</para>

      <para>Fortunately, the Jspresso framework allows you to implement
      property processors that can be registered with any property you define
      on a Jspresso managed component. This includes :</para>

      <orderedlist>
        <listitem>
          <para>Pre-update property processors to cover pre-update controls on
          setters for scalar, reference and collection properties and adders
          and removers for collection properties.</para>
        </listitem>

        <listitem>
          <para>Interceptors to transform the value before it's actually set
          on the business object.</para>
        </listitem>

        <listitem>
          <para>Post-update property processors to trigger post-update
          computations for scalar, reference and collection properties and
          adders and removers for collection properties.</para>
        </listitem>
      </orderedlist>

      <para>Let's define some simple integrity constraints on our domain model
      :</para>

      <itemizedlist>
        <listitem>
          <para>An employee first name should be automatically formatted like
          this : first letter capitalized and the remaining letters in lower
          case; this is a setter interceptor on the employee first name
          property. We could have implemented this constraint using a regular
          expression check, but this would have forced the end user to type-in
          a compliant first name instead of automatically making it compliant
          through computation.</para>
        </listitem>

        <listitem>
          <para>An employee can not be hired if he is not at least 18 years
          old; this is a pre-update integrity processor on the employee birth
          date property.</para>
        </listitem>
      </itemizedlist>

      <para>The following SJS fragment declares these processors :</para>

      <para><programlisting language="groovy">Entity('Employee'
       ...
       <emphasis role="bold">processor:'EmployeePropertyProcessors'</emphasis><co
            id="Employee-processors_1" />) {
  ...
  string_32 'firstName', mandatory:true, <emphasis role="bold">processors:'FirstNameProcessor'</emphasis><co
            id="Employee-processors_2" />
  ...
  date 'birthDate', <emphasis role="bold">processors:'BirthDateProcessor'</emphasis><co
            id="Employee-processors_3" />
  ...
}</programlisting><calloutlist>
          <callout arearefs="Employee-processors_1">
            <para>We declare a a class for holding all the property processors
            of the Employee entity, i.e.
            <code>EmployeePropertyProcessors</code>. By convention, the
            processor package is determined from the namespace, i.e.
            <classname>org.jspresso.hrsample.model.processor.EmployeePropertyProcessors</classname>.
            Each property processor will be an internal static class of this
            enclosing type.</para>
          </callout>

          <callout arearefs="Employee-processors_2">
            <para>We declare <code>FirstNameProcessor</code> as being a
            processor for the <code>firstName</code> property.</para>
          </callout>

          <callout arearefs="Employee-processors_3">
            <para>We declare <code>BirthDateProcessor</code> as being a
            processor for the <code>birthDate</code> property.</para>
          </callout>
        </calloutlist></para>

      <para>As described in the SJS fragment, we are going to create an
      <code>EmployeePropertyProcessors</code> class in the new package
      <code>org.jspresso.hrsample.model.processor</code>.</para>

      <para>Let's see what those processors look like by looking at the
      <filename>EmployeePropertyProcessors.java</filename> source file
      :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.model.processor;

import java.util.Date;

import org.jspresso.hrsample.model.Employee;
import org.jspresso.framework.util.bean.integrity.EmptyPropertyProcessor;
import org.jspresso.framework.util.bean.integrity.IntegrityException;

/**
 * Employee property processors.
 */
public class EmployeePropertyProcessors {

  /**
   * Birth date property processor.
   */
  public static class BirthDateProcessor extends <co
            id="BirthDateIntegrityProcessorImpl" />
      EmptyPropertyProcessor&lt;Employee, Date&gt; {

    /**
     * Checks that the employee age is at least 18.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public void preprocessSetter(Employee employee, <co
            id="preprocessSetterIntegrity" />
        Date newBirthDate) {
      if (newBirthDate == null
          || employee.computeAge(newBirthDate).intValue() &lt; 18) {
        throw new IntegrityException("Age is below 18", "age.below.18"); <co
            id="IntegrityException" />
      }
    }
  }

  /**
   * First name property processor.
   */
  public static class FirstNameProcessor extends <co
            id="FirstNameIntegrityProcessorImpl" />
      EmptyPropertyProcessor&lt;Employee, String&gt; {

    /**
     * Formats the new first name. The formatting is :
     * &lt;li&gt;Capitalize the 1st letter
     * &lt;li&gt;Lower case all the other letters
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public String interceptSetter(Employee employee, <co
            id="postprocessSetterIntegrity" />
        String newFirstName) {
      if (newFirstName != null &amp;&amp; newFirstName.length() &gt; 0) {
        StringBuffer formattedName = new StringBuffer();
        formattedName.append(newFirstName.substring(0, 1).toUpperCase());
        formattedName.append(newFirstName.substring(1).toLowerCase());
        return formattedName.toString(); <co id="formattedName" />
      }
      return super.interceptSetter(employee, newFirstName);
    }
  }
}</programlisting><calloutlist>
          <callout arearefs="BirthDateIntegrityProcessorImpl">
            <para>We declare an internal class as being a processor for the
            birth date property and inherit from the
            <code>EmptyPropertyProcessor</code> empty adaptor class.</para>
          </callout>

          <callout arearefs="preprocessSetterIntegrity">
            <para>We override the <code>preprocessSetter</code> to implement
            the age over 18 constraint.</para>
          </callout>

          <callout arearefs="IntegrityException">
            <para>Whenever the condition is not met, we throw an
            <code>IntegrityException</code> to stop the chain and notify the
            outside that the property update could not be performed. The
            second parameter in the exception is a bundle key used for
            internationalization; this is not covered by this section.</para>
          </callout>

          <callout arearefs="FirstNameIntegrityProcessorImpl">
            <para>We declare an internal class as being a processor for the
            first name property and inherit from the
            <code>EmptyPropertyProcessor</code> empty adaptor class.</para>
          </callout>

          <callout arearefs="postprocessSetterIntegrity">
            <para>We override the <code>interceptSetter</code> to implement
            the first name formatting.</para>
          </callout>

          <callout arearefs="formattedName">
            <para>We change the first name actually set in the employee to the
            new computed value.</para>
          </callout>
        </calloutlist>Each processor declared on a property is potentially a
      pre, post processor and interceptor. To make a property processor a
      pre-only processor, just leave the <code>postprocessSetter</code> and
      interceptSetter methods implementation empty. Same applies to make
      property processor a post-only or intercept-only processor by leaving
      the other methods implementation empty. We encourage you, as shown in
      the example above, to make all your processors inherit from the
      <code>EmptyPropertyProcessor</code> adapter class which provide empty
      implementations for all required methods and then to override the method
      you want to provide an implementation for.</para>
    </section>

    <section>
      <title>Hibernate mapping</title>

      <para>This is actually nothing to do. When you compiled the project with
      maven, all the Hibernate mapping files were automatically generated by
      xDoclet in the
      <filename>/hrsample/core/target/generated-resources/xdoclet</filename>
      folder that is already declared as a source folder in the Eclipse
      project. You might have a look to the generated files to chack how
      Jspresso translated your model description into Hibernate mapping
      files.</para>
    </section>
  </section>

  <section>
    <title>Describing the views</title>

    <para>Now that we designed the complete domain model, it is time to make
    it available to the end-user. So we need to design the views that will be
    part of our application. As promised, we won't need a single line of GUI
    code to achieve that. As for the domain model description, the goal will
    be :</para>

    <orderedlist>
      <listitem>
        <para>To define precisely what we want.</para>
      </listitem>

      <listitem>
        <para>To assemble descriptor beans in order to translate what has been
        specified into Jspresso view descriptors.</para>
      </listitem>
    </orderedlist>

    <para>As far as we begin to deal with GUI, internationalization (I18N)
    comes into the game. Jspresso is definitely targeted at multi-lingual
    applications and as such, fully supports internationalized GUIs.</para>

    <para>The views description will logically go to the
    <code>org.jspresso.hrsample.view</code> package. An empty SJS file has
    been created in the following folder (you can quickly navigate to it using
    the Eclipse <quote>Open resource</quote> function) :</para>

    <para><filename>hrsample/core/src/main/dsl/view.groovy</filename></para>

    <para>Here is what it looks like :</para>

    <para><programlisting language="groovy">// Implement your views here using the SJS DSL.
</programlisting></para>

    <para>In order to ease the work of the GUI designer, Jspresso provides a
    view tester tool that enables an immediate java swing preview of each
    described view fragment. At the beginning of this tutorial, you should
    have imported the <quote>view tester</quote> configuration that alows you
    to launch the tool. No further configuration is needed.</para>

    <note>
      <para>You are able to choose the language to use for displaying the
      tested view through the use of the <code>-language</code> option in the
      <quote>view tester</quote> launch configuration. Whenever this option is
      omitted, the view tester will fall back to the platform default locale.
      Changing the language when testing a view will allow for early missing
      translations identification.</para>
    </note>

    <note>
      <para>The view tester tool will not display fully functional views. For
      instance, list of values won't be available (the button will be
      displayed but won't trigger anything) since the view is not instantiated
      in the scope of a complete Jspresso application - no database, ... Its
      goal is only targeted at quickly previewing the GUI layout to promote
      agile development.</para>
    </note>

    <para>We can now begin to describe our first views.</para>

    <section>
      <title>Component views</title>

      <para>One of the most heavily used type of view is the form-like
      component view. We will see in this section how to describe, translate
      and further customize a component view.</para>

      <section>
        <title>The first shot</title>

        <para>Let's describe our first component view on the company entity in
        the <filename>view.groovy</filename> file:</para>

        <para><programlisting language="groovy">form<co id="Company.pane_1" /> 'Company.pane'<co
              id="Company.pane_2" />,
  parent:'decoratedView'<co id="Company.pane_3" />,
  labelsPosition:'ABOVE'<co id="Company.pane_4" />,
  columnCount:3<co id="Company.pane_5" /></programlisting><calloutlist>
            <callout arearefs="Company.pane_1">
              <para>We declare a form-like component view.</para>
            </callout>

            <callout arearefs="Company.pane_2">
              <para>By convention, the view infers its model from its name,
              i.e. the <code>Company</code> entity in this case. Wenever you
              don't want to follow this convention, you can still override the
              model type using the <code>model</code> attribute.</para>
            </callout>

            <callout arearefs="Company.pane_3">
              <para>We make the view inherit from a Jspresso standard one
              which surrounds the view with a title.</para>
            </callout>

            <callout arearefs="Company.pane_4">
              <para>We want each property label to be positioned above the
              property field. We could have used the <code>ASIDE</code>
              constant to indicate that we wanted the labels aside the
              fields.</para>
            </callout>

            <callout arearefs="Company.pane_5">
              <para>We want the component view to be organized in 3
              columns.</para>
            </callout>
          </calloutlist></para>

        <para>Although there are plenty of configurations that can be applied
        to view descriptions (font, color, properties subset, ...), the
        previous SJS fragment is fully enough to get our first view up and
        running using the view tester.</para>

        <note>
          <para>Unlike for the model components, there is no java generation
          nor compilation step involved; the view descriptors are just handled
          at runtime by Jspresso.</para>
        </note>

        <para>The view tester launch configuration has been set-up to
        instanciate and display a view whose id is <quote>testView</quote>. As
        a result, we simply have to reference the view to test in the
        <filename>view.</filename>groovy file as follows :</para>

        <para><programlisting language="groovy">bean 'testView',
  parent:'Company.pane'</programlisting></para>

        <para>Now, launching the tester will produce the following result
        :</para>

        <para><figure>
            <title>The first component view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-pane.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>You will notice several things on the screenshot above
        :</para>

        <itemizedlist>
          <listitem>
            <para>The <code>name</code> label has been colored in red and has
            a star marker. It is to indicate that the name property is
            mandatory as declared during the <link linkend="Nameable_5">domain
            model design</link>.</para>
          </listitem>

          <listitem>
            <para>The <code>createTimestamp</code> and
            <code>lastUpdateTimestamp</code> property fields have been made
            non-editable as <link linkend="Traceable_3">we declared
            them</link>.</para>
          </listitem>

          <listitem>
            <para>The <code>contact</code> inlined component has been splitted
            into its 4 properties (<code>address</code>, <code>city</code>,
            <code>phone</code> and <code>email</code>). The component
            properties are referred to using a nested property notation like
            <emphasis>component.property</emphasis>.</para>
          </listitem>

          <listitem>
            <para>The <code>city</code> property field has been added a list
            of value (LOV) button. This button will bring a dialog box
            allowing the user to look-up available cities and select
            one.<figure>
                <title>City LOV</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" contentdepth="60%"
                               fileref="../screenshots/Lov.jpg" scalefit="1"
                               width="100%" />
                  </imageobject>
                </mediaobject>
              </figure></para>

            <para>Of course, leaving the field with an incomplete value would
            auto-complete the value if the typed-in string is sufficient to
            determine one and only one city or bring up the LOV dialog without
            for the user to push the LOV button. This reference field
            behaviour is only the consequence of having declared the
            <code>ContactInfo</code> -&gt; <code>City</code> <link
            linkend="ContactInfo_ref_1">relationship</link>. In the view
            tester tool, the search button and the auto-completion are not
            functional since we don't have any backend to rely on.</para>
          </listitem>

          <listitem>
            <para>Whenever you try to type-in "aze" in the email property
            field, you will obtain the following error message :<figure>
                <title>Regular expression error message</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" contentdepth="60%"
                               fileref="../screenshots/regexp_error.jpg"
                               scalefit="1" width="100%" />
                  </imageobject>
                </mediaobject>
              </figure></para>

            <para>This is due to the <link linkend="ContactInfo_2">constraint
            we applied on the email property</link> in the
            <code>ContactInfo</code> inlined component.</para>
          </listitem>

          <listitem>
            <para>Finally, there are terms that are missing translations in
            English. Whenever Jspresso detects such a situation, it will
            "translate" the term using the following pattern
            <emphasis>[language:translation key]</emphasis>. This strategy
            allows for easy and fast identification of missing translations.
            You will also notice that the name label has been correctly
            translated. This is because "name" is part of the default
            translations. Of course, you may override this translation if you
            wish in the application I18N property files.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Internationalization</title>

        <para>To complete the view design, we are going to translate the
        missing terms in the I18N property files we've opened previously. To
        ease the editing of the I18N property files, we recommend the use of a
        very good Eclipse plug in : the <ulink
        url="http://www.resourcebundleeditor.com">Resource Bundle
        Editor</ulink>.</para>

        <para>For instance, <filename>Messages_en.properties</filename> could
        be :</para>

        <para><programlisting>age.below.18 = Employee is not 18 years old.

org.jspresso.hrsample.model.Company = Company

contact.address = Address
contact.city    = City
contact.email   = Email
contact.phone   = Phone

createTimestamp = Created

hrsample.name = Human Resources management

lastUpdateTimestamp = Updated

zip = Code postal</programlisting>And Messages_fr.properties :</para>

        <para><programlisting>age.below.18 = L'employ\u00E9 n'a pas 18 ans.

org.jspresso.hrsample.model.Company = Soci\u00E9t\u00E9

contact.address = Adresse
contact.city    = Ville
contact.email   = Email
contact.phone   = T\u00E9l\u00E9phone

createTimestamp = Cr\u00E9\u00E9 le

hrsample.name = Gestion des ressources humaines

lastUpdateTimestamp = Mis \u00E0 jour le

zip = Zip code</programlisting>Relaunching the view test with the English
        locale will produce :<figure>
            <title>Company view with English translation</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-pane_en.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>And with the French locale :<figure>
            <title>Company view with French translation</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-pane_fr.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>Customization</title>

        <para>We certainly need to further customize the company view. This
        includes :</para>

        <itemizedlist>
          <listitem>
            <para>Selecting the properties we want to display.</para>
          </listitem>

          <listitem>
            <para>Ordering the displayed properties.</para>
          </listitem>

          <listitem>
            <para>Spanning properties across multiple columns.</para>
          </listitem>
        </itemizedlist>

        <para>Assume that we would like to hide the tracing properties since,
        after all, they are technical data. Then, we want to organize the
        fields in 2 columns instead of 3 having the company name to span over
        the 2 columns. Then we keep the order name, address, city, phone and
        email.</para>

        <para>The following change to the view descriptor achieves that
        :</para>

        <para><programlisting language="groovy">form 'Company.pane',
  ...
  columnCount:2<co id="Company.pane.custo_1" />,
  ...
  fields<co id="Company.pane.custo_2" />:['name','contact.address','contact.city','contact.phone','contact.email'],
  widths<co id="Company.pane.custo_3" />:[name:2]</programlisting><calloutlist>
            <callout arearefs="Company.pane.custo_1">
              <para>We reduce the number of columns to 2.</para>
            </callout>

            <callout arearefs="Company.pane.custo_2">
              <para>We explicitely declare the ordered list of properties we
              want to display.</para>
            </callout>

            <callout arearefs="Company.pane.custo_3">
              <para>We make the <code>name</code> property span 2
              columns.</para>
            </callout>
          </calloutlist></para>

        <note>
          <para>Jspresso supports the use of nested properties for all
          descriptors. For instance, in the example above, we have used the
          <code>contact.phone</code> nested property of the
          <code>Company</code> entity. It simply means the the field will
          reference <code>company -&gt; contact -&gt; phone</code> of its
          underlying company model.</para>
        </note>

        <para>Relaunching the view tester will produce the following output
        :</para>

        <para><figure>
            <title>The customized company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-pane_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>You will notice that the name field is now alone on its line,
        spanning over the 2 columns of the view. Of course, the tracing
        properties have disappeared from the view.</para>

        <para>There would have been another way to customize subset of
        displayed properties for the company entity. We could have set on the
        <code>Company</code> entity the <code>rendered</code> attribute that
        allows to set an ordered list of properties to be displayed by default
        when an company instance is displayed in any view. This change would
        have impacted all the application company views (including tables for
        instance) except the ones declare their own property list.</para>

        <para>To summarize, a component view will display (higher in the list
        has higher priority) :</para>

        <orderedlist>
          <listitem>
            <para>If set on the view, the <code>fields</code>
            properties.</para>
          </listitem>

          <listitem>
            <para>If set on the model, the <code>rendered</code>
            properties.</para>
          </listitem>

          <listitem>
            <para>All the properties, in their declaration order except the
            collection properties. In that case, the inlined components are
            splitted as we saw it for the first shot.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Composite views</title>

      <para>Now that we have seen how to provide the end-user with basic
      component editing, we need to compose these views into more complex
      ones. As an example, let's say that you would like to have the tracing
      properties back in the company view, but in a separated panel so that
      the main screen is not overloaded by fields that are not useful at first
      sight. A classic way go is to introduce tabs with the tracing properties
      available in a secondary tab.</para>

      <section>
        <title>The first composite view</title>

        <para>Such a tab panel is called a composite view; its objective is to
        assemble sub-views into a more user-friendly graphical structure. In
        the following SJS fragment, we will describe the component view to
        display the tracing properties and assemble the company view and the
        tracing view into a tab composite view :</para>

        <para><programlisting language="groovy">form<co id="Traceable.pane_1" /> 'Traceable.pane'<co
              id="Traceable.pane_2" />,
  model:'Traceable',
  labelsPosition:'ABOVE',
  columnCount:2,
  fields:['createTimestamp','lastUpdateTimestamp']

tabs<co id="Traceable.pane_3" /> 'Company.tab.pane',
  views<co id="Traceable.pane_4" />:['Company.pane','Traceable.pane']</programlisting><calloutlist>
            <callout arearefs="Traceable.pane_1">
              <para>We declare a new form view descriptor for the tracing
              properties.</para>
            </callout>

            <callout arearefs="Traceable.pane_2">
              <para>It's backed by any <code>Traceable</code> model.</para>
            </callout>

            <callout arearefs="Traceable.pane_3">
              <para>We declare a tabbed composite view in order to assemble
              our forms.</para>
            </callout>

            <callout arearefs="Traceable.pane_4">
              <para>We assign an ordered list of views to be displayed in the
              tabs. Of course, these sub-views may be any type of view,
              including other composite views.</para>
            </callout>
          </calloutlist></para>

        <para>After having completed the I18N property files with the
        <code>org.jspresso.hrsample.model.Traceable</code> entry, we can
        launch the view tester on the <code>Company.tab.pane</code> view
        :</para>

        <para><figure>
            <title>The tabbed company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-tab-pane.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>Improving the view aspect</title>

        <para>We can make the view a little more attractive by adding icons
        and tool tips. Using Jspresso, it is quite straightforward by
        completing the descriptors :</para>

        <itemizedlist>
          <listitem>
            <para>For the icons, we want to assign an image to the model
            components themselves so that whenever one of them is used as
            model, the framework may decide to use the image to improve the
            view appearance.</para>
          </listitem>

          <listitem>
            <para>For the tool tips, it is more linked to the user interface
            itself, so we will declare it on the view; but in fact, we will
            not declare a tool tip as such but rather bring a description
            information to the view so that the framework may, at runtime,
            transform this description as a tool tip.</para>
          </listitem>
        </itemizedlist>

        <para>The following SJS fragment assigns an icon image to the
        <code>Company</code> and the <code>Traceable</code> components
        :</para>

        <para><programlisting language="groovy">Interface('Traceable',
          ...
          icon<co id="Traceable-icon_1" />:'traceable-48x48.png') {
  ...
}

Entity('Company',
          ...
          icon:'company-48x48.png') {
  ...
}</programlisting><calloutlist>
            <callout arearefs="Traceable-icon_1">
              <para>We declare the image used to reference the image to be
              used to represent a <code>Traceable</code> component. Same
              applies for the <code>Company</code> entity. The actual image
              URL used is deduced by convention from the namespace. In that
              case, the following pseudo URL is used :
              <filename>classpath:org/jspresso/hrsample/images/traceable-48x48.png</filename>.</para>
            </callout>
          </calloutlist></para>

        <para>And we assign a more friendly description to both component
        views. As for every potentially displayed string, these descriptions
        are entries in the I18N property files that we will translate. The
        following SJS fragments achieves that :</para>

        <para><programlisting language="groovy">form 'Traceable.pane',
  ...
  description:'traceable.editing'<co id="traceable.editing" />

form 'Company.pane',
  ...
  description:'company.editing'</programlisting><calloutlist>
            <callout arearefs="traceable.editing">
              <para>We declare an I18N entry to describe the traceable
              component view. Same applies for the company component
              view.</para>
            </callout>
          </calloutlist></para>

        <para>Re-launching the view tester displays the following window
        :</para>

        <para><figure>
            <title>The improved tab company view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-tab-pane_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>There are several remarks regarding what we have just done
        :</para>

        <itemizedlist>
          <listitem>
            <para>Name, description and icons can be used in different layers
            of the application. Jspresso will then take advantage of these
            attributes to generate tool tips, to place icons, to fill-in
            labels in the following order (higher in the list has higher
            priority) :</para>

            <orderedlist>
              <listitem>
                <para>Name, description and icon image URL (each attribute can
                be independently overridden) set on the view
                descriptor.</para>
              </listitem>

              <listitem>
                <para>Name, description and icon image URL set the model
                descriptor on which the view descriptor relies.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>To reference an image to be used as icon, you may use any
            kind of URL (HTTP, file) but Jspresso provides a very useful,
            specialized URL which is the <code>classpath:</code> URL. Such a
            URL may be used to reference any resource present in the
            application classpath. As an example, we have used the
            <code>classpath:org/jspresso/hrsample/images/company-48x48.png</code>
            URL to load an image from the
            <code>org.jspresso.hrsample.images</code> package (this type of
            URL is used by convention in SJS but can be overriden if
            necessary). This prevents the developer from hard-coding
            references to application external resources and promotes
            portability across deployment environments.</para>
          </listitem>

          <listitem>
            <para>Whenever you want to link an icon image to a component or a
            view, you don't have to care about the actual size of the image.
            The framework will dynamically resize it for you at runtime,
            depending of what it wants to use it for. As a general rule, you
            might consider using little over sized images (48x48 is a good
            compromise) since image reduction won't degrade quality whereas
            image expansion will.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Other composite views</title>

        <para>Jspresso offers a rich set of composite view descriptors.
        Although we won't detail them in this section, the following
        enumeration lists them :</para>

        <itemizedlist>
          <listitem>
            <para><code>BasicTabViewDescriptor</code> (or <code>tabs</code> in
            SJS) to organize sub-views in tabs.</para>
          </listitem>

          <listitem>
            <para><code>BasicBorderViewDescriptor</code> (or
            <code>border</code> in SJS) to layout up to 5 sub-views at north,
            south, east, west and center.</para>
          </listitem>

          <listitem>
            <para><code>BasicSplitViewDescriptor</code> (or
            <code>split_[horizontal|vertical]</code> in SJS) to layout 2
            sub-view within a separator splitted panel. The orientation of the
            split may be vertical or horizontal.</para>
          </listitem>

          <listitem>
            <para><code>BasicEvenGridViewDescriptor</code> (or
            <code>evenGrid</code> in SJS) to layout an arbitrary number of
            sub-views into a grid with equally sized cells. As for component
            views, you only set up the driving dimension (horizontal or
            vertical), the maximum number of cells in the driving dimension
            and an ordered list of the sub-views to be contained in the cells.
            Whenever the line (or column) reaches the maximum number of cells
            allowed, a new line (or column) is created.</para>
          </listitem>

          <listitem>
            <para><code>BasicConstrainedGridViewDescriptor</code> (or
            <code>grid</code> in SJS) lets you organize sub-views in a grid
            where each cell behaviour is determined by the following
            attributes :</para>

            <itemizedlist>
              <listitem>
                <para>position (row, column)</para>
              </listitem>

              <listitem>
                <para>height (row span) and width (column span)</para>
              </listitem>

              <listitem>
                <para>width resizability and height resizability</para>
              </listitem>
            </itemizedlist>

            <para>This is certainly the most complex composite view descriptor
            but also the most powerful one.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Collection views</title>

      <para>The next step in our frontend development is to display (and edit)
      collection relationships between components. We will achieve this using
      collection views; these type of views include multi-column table views
      and list views. In this section, you will learn how to build a
      multi-level master-detail view on the company structure.</para>

      <section>
        <title>The first collection view</title>

        <para>We need to give access to the end-user a mean to edit the
        departments contained in a company. As we defined it in the domain
        model, there is a 1-N relationship between the two so we will design a
        table view that displays 1 department per row and link this view to
        the company one.</para>

        <para>Let's consider the following SJS fragment :</para>

        <para><programlisting language="groovy">table<co
              id="BasicTableViewDescriptor" /> 'Company-departments.table'<co
              id="Company-departments-model" />,
  parent:'decoratedView'

split_vertical<co id="BasicSplitViewDescriptor" /> 'Company.organization.view'<co
              id="Company-model" />,
  model:'Company',
  top<co id="leftTopViewDescriptor" />:'Company.tab.pane',
  bottom<co id="rightBottomViewDescriptor" />:'Company-departments.table'</programlisting><calloutlist>
            <callout arearefs="BasicTableViewDescriptor">
              <para>We declare a table view.</para>
            </callout>

            <callout arearefs="Company-departments-model">
              <para>Unlike component views, collection views are backed by the
              N end of a 1-N relationship. Here, we reference the
              <code>Company</code> -&gt; <code>Department</code> relationship
              we've previously declared in the domain model. This model is
              inferred by the naming convention, i.e. the name begins with
              <code>Company-department</code> which is the implicit identifier
              of the <code>Company</code> -&gt; <code>Department</code>
              relationship.</para>
            </callout>

            <callout arearefs="BasicSplitViewDescriptor">
              <para>We organize the departments table view and the company
              view in a new type of composite view : a vertical split
              view.</para>
            </callout>

            <callout arearefs="Company-model">
              <para>This composite view is still a view backed by a
              company.</para>
            </callout>

            <callout arearefs="leftTopViewDescriptor">
              <para>The top part of the split view is the company component
              view.</para>
            </callout>

            <callout arearefs="rightBottomViewDescriptor">
              <para>The bottom part of the split view is the departments table
              view.</para>
            </callout>
          </calloutlist></para>

        <para>After adding the necessary translations as usual, and linking a
        new icon to describe the department entities, re-launching the view
        tester produces the following window :</para>

        <para><figure>
            <title>The company and departments view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-organization-view.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Of course, this is not enough to be able to manage the
        departments of a company. We are missing a way to add and remove
        departments.</para>
      </section>

      <section>
        <title>Assigning an action map to a view</title>

        <para>Each view can be assigned an action map. An action map is a set
        of actions grouped by category. Consider an application menu bar. In
        this menu bar, you will find menus -action categories- like "File",
        "Edit", "Help" and in each menu, a list of individual actions. This is
        the exact same principle of an action map, but instead of being a
        rendered as a menu bar, the Jspresso framework will make a tool bar
        out of it, and in certain situations a context menu, that will make
        the actions available to the end user.</para>

        <para>In this section, we won't go describe in detail how to develop
        and declare an action. Actually, Jspresso comes with a large set of
        pre-defined, ready-to-use general purpose actions (and even action
        maps) that are sufficient for most classic operations. Look at the
        following SJS fragment :</para>

        <para><programlisting language="groovy">table 'Company-departments.table',
  ...
  actionMap<co id="masterDetailActionMap" />:'masterDetailActionMap'</programlisting><calloutlist>
            <callout arearefs="masterDetailActionMap">
              <para>We assign the predefined master-detail action map to the
              departments table view.</para>
            </callout>
          </calloutlist></para>

        <para>These new lines bring us what we need to be able to operate
        efficiently the company departments relationship. Re-launching the
        view tester modifies the previous view :</para>

        <para><figure>
            <title>The improved company and departments view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-organization-view_reworked.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>Using this improved master detail view, we are now able to
        completely manage the departments of a company :</para>

        <itemizedlist>
          <listitem>
            <para>We can add, remove and duplicate a department.</para>
          </listitem>

          <listitem>
            <para>We copy, cut and paste a department.</para>
          </listitem>
        </itemizedlist>

        <para>Of course, we might need to refine and re-order the department
        properties displayed in the table view. Do you remember what we did
        previously for the company component view ? We will do the same for
        the departments table collection view, but instead of working directly
        on the view, we will rework the department entity itself globally set
        its rendered properties; whenever we need a department based view to
        be customized differently, we still have the option to override this
        global setting on the view descriptor itself. So let's go back to the
        department entity descriptor :</para>

        <para><programlisting language="groovy">Entity('Department',
    ...
    rendered<co id="renderedProperties" />:['ouId','name','manager','contact']) {
  ...
}</programlisting><calloutlist>
            <callout arearefs="renderedProperties">
              <para>We set the ordered list of department default rendered
              properties.</para>
            </callout>
          </calloutlist></para>

        <para>And when we re-launch the view tester :</para>

        <para><figure>
            <title>The improved company and departments view with refined
            department columns</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-organization-view_reworked_2.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>There are several things to notice on the screenshot above
        and that you can experiment in the view tester :</para>

        <itemizedlist>
          <listitem>
            <para>The columns have been refined to match the list of
            department's rendered properties.</para>
          </listitem>

          <listitem>
            <para>Mandatory columns have been marked with an asterisk.</para>
          </listitem>

          <listitem>
            <para>You can reorder and resize the columns as you wish.</para>
          </listitem>

          <listitem>
            <para>Some actions (duplicate, remove, cut and copy) may be
            applied on 1 selected item but also on a set of selected items; in
            that case, multiple selection is performed by maintaining the
            <keycode>CTRL</keycode> (increase selection with an individual
            item) or the <keycode>SHIFT</keycode> (range selection) and even
            both (increase selection with a range) key pressed when selecting
            the table rows.</para>
          </listitem>

          <listitem>
            <para>You can sort the lines of a table view on 1 column by
            clicking the column header and even on multiple columns (look at
            the address and city columns) by keeping the
            <keycode>CTRL</keycode> key pressed when clicking multiple column
            headers.</para>
          </listitem>

          <listitem>
            <para>The editable columns have been assigned an editor that
            matches their model; this includes associations LOV (see the
            editing manager cell above) and field controls and
            auto-completion.</para>
          </listitem>

          <listitem>
            <para>You might right-click on a selected line to open a context
            menu (not shown here) that will give you access to the same
            actions that are present in the tool bar.</para>
          </listitem>
        </itemizedlist>

        <para>To complete the organization view, we now need to manage the
        teams of a department.</para>
      </section>

      <section>
        <title>Nested master-detail views</title>

        <para>To handle the <code>Department</code> -&gt; <code>Team</code>
        relationship, we need to add another collection view backed by the 1-N
        association. The idea is to append this table view at the bottom of
        the previous one, using a new split view. Based on what we've already
        achieved, this is quite straight forward except for a slight but
        tricky difference : the teams to be displayed by the new table view
        are not directly related to the company but to the
        <emphasis>selected</emphasis> department in the intermediate
        department table view. So we need to instruct Jspresso that we want
        this nested master-detail behaviour.</para>

        <para>Let's first describe the teams collection view; for the sake of
        the tutorial, we will refine the teams displayed columns on the view
        itself instead of globally configuring the rendered properties of the
        team entity :</para>

        <para><programlisting language="groovy">table 'Department-teams.table',
  parent:'decoratedView',
  actionMap:'masterDetailActionMap',
  columns<co id="columnViewDescriptors" />:['ouId','name','manager']  </programlisting><calloutlist>
            <callout arearefs="columnViewDescriptors">
              <para>We setup the ordered list of columns we want to display on
              the teams table.</para>
            </callout>
          </calloutlist></para>

        <para>This table view definition is strictly identical to the previous
        department view. We now need to assemble the
        <code>Company-departments.table</code> and the new
        <code>Department-teams.table</code> into a split view and tell
        Jspresso to drive the teams table content with the departments table
        selection :</para>

        <para><programlisting language="groovy">split_vertical<co
              id="Departments.and.teams.view" /> 'Departments.and.teams.view',
  cascadingModels:true<co id="cascadingModels" />,
  top<co id="Company-departments.table" />:'Company-departments.table',
  bottom<co id="Department-teams.table" />:'Department-teams.table'</programlisting><calloutlist>
            <callout arearefs="Departments.and.teams.view">
              <para>We declare a new split view.</para>
            </callout>

            <callout arearefs="cascadingModels">
              <para>We declare this composite view a master-detail view for
              Jspresso to track the departments selection.</para>
            </callout>

            <callout arearefs="Company-departments.table">
              <para>We make the departments table view the top part of the
              view.</para>
            </callout>

            <callout arearefs="Department-teams.table">
              <para>We make the teams table view the top part of the
              view.</para>
            </callout>
          </calloutlist></para>

        <para>The crucial part of the previous definition is the use of the
        <code>cascadingModels</code> attribute. It tells the framework that
        the sub-views we are composing are not straightly backed by properties
        of the master model, but each one will be driven by some kind of
        selection in the previous one. Note that this attribute is available
        on all composite views. Although some types of composite views are
        more adapted to master-detail relationships (the split view for
        example), you might very well decide to present arbitrary deep nested
        master-detail views in any kind of composite view (a tab view for
        example; in this case, each tab will be a detail of the previous
        one).</para>

        <para>Then, we need to refactor the
        <code>Company.organization.view</code> to substitute the current
        departments table view by our new
        <code>Departments.and.teams.view</code> :</para>

        <para><programlisting language="groovy">split_vertical 'Company.organization.view',
  model:'Company',
  top:'Company.tab.pane',
  bottom:'Departments.and.teams.view'<co id="Bottom.reworked" /></programlisting><calloutlist>
            <callout arearefs="Bottom.reworked">
              <para>We assign the departments and teams master-detail view as
              being now the bottom part of the company organization
              view.</para>
            </callout>
          </calloutlist></para>

        <para>After adding some new translations and icons for the team
        entity, we can relaunch the view tester and obtain the following
        screen where you can fully manage the departments of a company and the
        teams of a department :</para>

        <para><figure>
            <title>The company, departments and teams view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-organization-view_reworked_3.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Although we have already designed a fairly usable GUI, you
        might want to go one step further by presenting to the end-user a
        hierarchical tree view of the organization. This is what we are going
        to achieve in the next section.</para>
      </section>
    </section>

    <section>
      <title>Tree views</title>

      <para>Tree views are certainly the most complicated but also the most
      intuitive type of view to display and manage a structured model. Anyone
      who ever tried to build a truly MVC aware GUI using trees knows that
      there are many caveats to avoid. Jspresso drastically simplifies getting
      a tree view up and running while keeping its original description
      centric philosophy.</para>

      <section>
        <title>Simple tree levels</title>

        <para>Let's consider our next objective as inserting a new tab in the
        previous company view that shows the company structure in a tree view.
        Describing a tree view is a matter of describing each tree level and
        assembling them. To describe the company organization tree, we are
        going to declare :</para>

        <itemizedlist>
          <listitem>
            <para>1 tree view : <code>Company.tree</code>.</para>
          </listitem>

          <listitem>
            <para>1 tree level for the <code>Company</code> -&gt;
            <code>Department</code> 1-N relationship :
            <code>Company-departments.subtree</code> that will be the first
            child tree level in the company tree.</para>
          </listitem>

          <listitem>
            <para>1 tree level for the <code>Department</code> -&gt;
            <code>Team</code> 1-N relationship :
            <code>Department-teams.subtree</code> that will be the child tree
            level of the previous one.</para>
          </listitem>
        </itemizedlist>

        <para>Look at the following SJS fragment :</para>

        <para><programlisting language="groovy">treeNode<co
              id="BasicSimpleTreeLevelDescriptor" /> 'Department-teams.treeNode'<co
              id="Department-teams" />,
  rendered:'ouId'<co id="renderedProperty" />,
  actionMap<co id="actionMap" />:'masterDetailActionMap'

treeNode 'Company-departments.treeNode',
  rendered:'ouId',
  actionMap:'masterDetailActionMap'

tree<co id="BasicTreeViewDescriptor" />('Company.tree',
  rendered:'name',
  icon<co id="Company.tree.icon" />:'structure-48x48.png') {
  subTree<co id="childDescriptor2" />('Company-departments.treeNode') {
    subTree<co id="childDescriptor" />('Department-teams.treeNode')
  }
}</programlisting><calloutlist>
            <callout arearefs="BasicSimpleTreeLevelDescriptor">
              <para>We declare a simple tree level.</para>
            </callout>

            <callout arearefs="Department-teams">
              <para>This simple tree level is backed by the
              <code>Department</code> -&gt; <code>Team</code> relationship
              (inferred from the naming convention) since it will display the
              teams of a department node.</para>
            </callout>

            <callout arearefs="renderedProperty">
              <para>Each node of a simple tree level - here it's a team - must
              be rendered by one of its property. When not set, the rendering
              property is chosen by the backing component itself. We want the
              <code>ouId</code> of a team to be displayed.</para>
            </callout>

            <callout arearefs="actionMap">
              <para>As for plain views, we can assign an action map to a
              simple tree level through the action map of its referenced list
              view descriptor. The registered action map will be accessible
              from a contextual menu. Here, we assign the same master-detail
              action map as we used for the table views.</para>
            </callout>

            <callout arearefs="BasicTreeViewDescriptor">
              <para>The tree view itself. It may be composed anywhere in the
              GUI.</para>
            </callout>

            <callout arearefs="Company.tree.icon">
              <para>The default icon used to display this view would be the
              icon declared in the company entity. Let's change it so that we
              have a different icon once we install the view in the
              tab.</para>
            </callout>

            <callout arearefs="childDescriptor">
              <para>We compose the sub-trees as we want them to appear
              hierarchically in the tree view. We set the
              <code>Company-departments.treeNode</code> as being the first
              child tree level of the tree.</para>
            </callout>

            <callout arearefs="childDescriptor2">
              <para>We set the <code>Department-teams.treeNode</code> tree
              level as being nested into the
              <code>Company-departments.treeNode</code> tree level.</para>
            </callout>
          </calloutlist></para>

        <para>The final step to reach the objective is to install the company
        tree view in a new tab of the company tab view. We do this by
        modifying the <code>Company.tab.pane</code> view as below :</para>

        <para><programlisting language="groovy">tabs 'Company.tab.pane',
  views:['Company.pane'<emphasis role="bold">,'Company.tree'</emphasis><co
              id="Company.tree" />,'Traceable.pane']</programlisting><calloutlist>
            <callout arearefs="Company.tree">
              <para>We declare another tab in the tab view.</para>
            </callout>
          </calloutlist></para>

        <para>We can now test the result.</para>

        <para><figure>
            <title>The company structure as a tree view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Company-organization-view_tree.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>Play around with the tree and with the tables. You will see
        that everything is always kept synchronized; we have a true MVC
        architecture.</para>
      </section>

      <section>
        <title>Composite tree levels</title>

        <para>There are situations where simple tree levels are just not
        enough to define complex tree structures. Imagine that you want to
        display, under each team, a subtree for the projects managed by a team
        and a subtree for the team members.</para>

        <para>Jspresso allows you aggregate the 2 simple tree levels (projects
        and team members) into a composite tree level and make this composite
        tree level the child level of the team tree level.</para>
      </section>
    </section>

    <section>
      <title>Other types of views</title>

      <para>Jspresso offers many other types of views to build arbitrarily
      complex views to enhance the user experience. We won't describe theme in
      detail in this tutorial but you can refer to the view descriptor
      reference section for a complete description. Fell free also to browse
      the complete sources of the HR sample application while running it to
      see them in action. Just remember that all the other standard view
      descriptors follow the exact same principles we have discovered in this
      section : assemble the descriptors to design what you need and let the
      framework work for you.</para>

      <para>It's time now to get our application really up and running.</para>
    </section>
  </section>

  <section>
    <title>Wiring the application</title>

    <para>As we saw it at the beginning of this tutorial, a Jspresso based
    application is cleanly organized into 4 separate layers :</para>

    <orderedlist>
      <listitem>
        <para>The model layer that contains the rich domain business
        objects</para>
      </listitem>

      <listitem>
        <para>The view layer that binds to and displays the model</para>
      </listitem>

      <listitem>
        <para>The backend layer which is responsible for handling the backend
        state and operations providing :</para>

        <itemizedlist>
          <listitem>
            <para>domain business objects manipulation and persistence</para>
          </listitem>

          <listitem>
            <para>transaction management</para>
          </listitem>

          <listitem>
            <para>rich application session that handles domain state, long
            running user transactions (independent from actual technical
            transactions and persistence) and user management (identification,
            credentials, authorizations, ...)</para>
          </listitem>

          <listitem>
            <para>actions backend part (domain services triggering, unit of
            work for handling in-memory transaction-aware domain state)</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>The frontend layer which is responsible for handling the user
        interactions :</para>

        <itemizedlist>
          <listitem>
            <para>user log in</para>
          </listitem>

          <listitem>
            <para>application starting and access to the various registered
            workspaces and modules</para>
          </listitem>

          <listitem>
            <para>construction and display of the views</para>
          </listitem>

          <listitem>
            <para>actions frontend part (wizards, success and error
            notifications, decisions, ...)</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </orderedlist>

    <para>We have already covered in details the model and view layers in this
    tutorial. This section will address the backend and frontend
    layers.</para>

    <section>
      <title>Configuring the backend layer</title>

      <section>
        <title>The backend controller</title>

        <para>The backend layer is organized around the backend controller.
        The backend controller is the conductor of all backend operations. As
        of now, Jspresso provides one concrete implementation of a backend
        controller : the Hibernate backend controller. This implementation
        provides all the backend management described above using hibernate
        and the hibernate spring stack (using hibernate and transaction
        templates). We will see later on how the spring hibernate stack is
        used when dealing with actions.</para>

        <para>As for <filename>model.groovy</filename> and
        <filename>view.groovy</filename>, the archetype has generated a ready
        to use Spring configuration file for the backend named
        <filename>backend.groovy</filename>. Here is what it looks like
        :</para>

        <para><programlisting language="groovy">// Implement your application backend here using the SJS DSL.
</programlisting>And the good news is that there is nothing to code here for a
        standard usage.</para>
      </section>

      <section>
        <title>The backend configuration</title>

        <para>The archetype also generated the <filename>config.xml</filename>
        Spring configuration file where we can define everything related to
        the deployment environment. The default configuration generated by the
        archetype uses HSQL DB as the database. In a production environment,
        you will adapt it to your targeted database. Although you could also
        define those configurations in SJS, there would not be much added
        value. So the Jspresso archetype does not generate any equivalent SJS
        file.</para>

        <para>Here is the file commented :</para>

        <para><programlisting language="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource" destroy-method="close"&gt; <co
              id="dataSource" />
  &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver" /&gt; <co
              id="dataSource-params" />
  &lt;property name="url" value="jdbc:hsqldb:mem:hrsample" /&gt; <co
              id="hsqldbmem" />
  &lt;property name="username" value="sa" /&gt;
  &lt;property name="password" value="" /&gt;
&lt;/bean&gt;

&lt;bean id="hibernateSessionFactory" parent="abstractHibernateSessionFactory"&gt; <co
              id="hibernateSessionFactory" />
  &lt;property name="hibernateProperties"&gt;
    &lt;props&gt;
      &lt;prop key="hibernate.query.substitutions"&gt;true 1, false 0, yes 'Y', no 'N'&lt;/prop&gt;
      &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/prop&gt;
      &lt;prop key="hibernate.order_updates"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.max_fetch_depth"&gt;1&lt;/prop&gt;
      &lt;prop key="hibernate.default_batch_fetch_size"&gt;8&lt;/prop&gt;
      &lt;prop key="hibernate.jdbc.batch_versioned_data"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.jdbc.use_streams_for_binary"&gt;true&lt;/prop&gt;
      &lt;prop key="hibernate.cache.region_prefix"&gt;hibernate.test&lt;/prop&gt;
      &lt;prop
        key="hibernate.cache.provider_class"&gt;org.hibernate.cache.EhCacheProvider&lt;/prop&gt;
      &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; <co
              id="hbm2ddl" />
      &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  &lt;property name="mappingLocations"&gt;
    &lt;list&gt;
      &lt;value&gt;classpath*:org/jspresso/hrsample/**/*.hbm.xml&lt;/value&gt; <co
              id="mappingLocations" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="dataSource">
              <para>We configure the data source that will be used in this
              environment.</para>
            </callout>

            <callout arearefs="dataSource-params">
              <para>In the development phase, we will use the well known HSQL
              DB in-memory database. HSQL DB will freshly start every-time the
              application itself starts and instantiate the data
              source.</para>
            </callout>

            <callout arearefs="hsqldbmem">
              <para>We configures the JDBC URL to use the in-memory
              database.</para>
            </callout>

            <callout arearefs="hibernateSessionFactory">
              <para>We configure the hibernate session factory with sensible
              values inheriting from the one brought by the hibernate standard
              configuration. For a complete reference of the meaning of the
              different parameters, please either refer to the hibernate or
              spring reference documentation. The most important here is that
              we tell hibernate to talk to the database using the HSQL DB
              dialect.</para>
            </callout>

            <callout arearefs="hbm2ddl">
              <para>Last but not least, since we configure a development
              environment, we tell hibernate to update (in our case create)
              the DB schema when starting so that our in memory HSQL DB gets
              populated with a fresh, empty, domain-synchronized
              schema.</para>
            </callout>

            <callout arearefs="mappingLocations">
              <para>We instruct hibernate to load the mapping files from
              resources located in any <code>org.jspresso.hrsample</code>
              subpackage.</para>
            </callout>
          </calloutlist></para>

        <para>Without any extra configuration, we actually have a fully
        functional hibernate aware backend relying on our domain model.</para>

        <para>The next phase consists in setting up the configuration for the
        frontend.</para>
      </section>
    </section>

    <section>
      <title>Configuring the frontend layer</title>

      <para>In this section, we will go through the different steps to finally
      have our application up and running.</para>

      <section id="frontend.controller">
        <title>The frontend controller</title>

        <para>The minimal frontend configuration requires the definition of
        the frontend controller. Although the backend controller is quite
        generic and requires no special parametrization most of the
        application final assembling is done in the frontend.</para>

        <para>The archetype generated a default
        <filename>frontend.groovy</filename> in the
        <code>org.jspresso.hrsample.frontend</code> package that contains a
        minimal frontend controller definition. Here is what it contains
        :</para>

        <para><programlisting language="groovy">// Implement your application frontend here using the SJS DSL.

/*
 * The workspaces and modules
 */

// Describe your workspaces and modules here.

controller<co id="applicationFrontController" /> 'hrsample.name'<co
              id="hrsample.name" />,
  icon:'icon.png'<co id="hrsample.iconImageURL" />,
  context:'hrsample'<co id="hrsample.loginContextName" />,
  language:'fr'<co id="hrsample.forcedStartingLocale" />,
  workspaces:[/*Reference your workspaces here.*/]</programlisting><calloutlist>
            <callout arearefs="applicationFrontController">
              <para>We declare our application frontend controller.</para>
            </callout>

            <callout arearefs="hrsample.name">
              <para>We define the name (in fact the I18N key) of the
              controller, or more generally of the application. It will be
              used as the frame title in the case of the swing
              controller.</para>
            </callout>

            <callout arearefs="hrsample.iconImageURL">
              <para>We define the icon of the controller, or more generally of
              the application. It will be used as the frame icon in the case
              of the swing controller.</para>
            </callout>

            <callout arearefs="hrsample.loginContextName">
              <para>We tell the controller the JAAS login context to use. We
              will go later into details regarding Jspresso and
              security.</para>
            </callout>

            <callout arearefs="hrsample.forcedStartingLocale">
              <para>Jspresso uses the locale of the logged-in user to
              translate the application. But before the user has actually
              logged-in, or for anonymous access, we still need to tell
              Jspresso which locale to use at least to translate the login
              dialog ! Whenever this property is omitted, the locale of the
              client machine (or browser language, depending on the used GUI
              technology) will be used.</para>
            </callout>
          </calloutlist></para>

        <para>The application is ready to be assembled.</para>
      </section>

      <section>
        <title>Securing the application access : Authentication</title>

        <para>Securing an application is a matter of handling :</para>

        <itemizedlist>
          <listitem>
            <para>Authentication (is the user the one he pretends to be
            ?).</para>
          </listitem>

          <listitem>
            <para>Authorization (is the user granted access to what he's
            trying to achieve ?).</para>
          </listitem>
        </itemizedlist>

        <para>Both of these topics are extensively covered by the Jspresso
        framework. This chapter covers the authentication part.</para>

        <para>Authentication in a Jspresso application relies on JAAS (Java
        Authentication and Authorization Service). We will not go into details
        about JAAS since there are excellent tutorials on the web (<ulink
        url="http://java.sun.com/j2se/1.5.0/docs/guide/security/jaas/tutorials/index.html">this
        one</ulink> for instance). Jspresso provides all the necessary
        plumbing to seamlessly integrate any JAAS login module and as of this
        writing, there are 3 login modules that come with the framework
        :</para>

        <itemizedlist>
          <listitem>
            <para>The development login module which does not require any
            backend and is perfectly suited for development.</para>
          </listitem>

          <listitem>
            <para>The LDAP login module which authenticates the user against
            an LDAP directory.</para>
          </listitem>

          <listitem>
            <para>The JDBC login module which authenticates the user against a
            relational database.</para>
          </listitem>
        </itemizedlist>

        <para>You may find many other, freely available, JAAS login modules to
        meet your needs (JDBC, ascii encrypted file, ...). In this section, we
        will secure our application with the development login module but the
        exact same principles (except for the module configuration itself) can
        be applied for others.</para>

        <para>As for any JAAS based login module, we will need a JAAS
        configuration. The archetype created the
        <filename>hrsample/conf/jaas.config</filename> that registers the
        development login module. Here is the generated
        <filename>jaas.config</filename> file detailed :</para>

        <para><programlisting>/** Login Configuration for the application **/

hrsample { <co id="hrsample-app" />
   org.jspresso.framework.security.auth.spi.DevelopmentLoginModule required <co
              id="DevelopmentLoginModule" />
       user=demo <co id="user" />
       password=demo <co id="password" />
       roles="administrator" <co id="roles" />
       custom.language=en; <co id="language" />
};</programlisting><calloutlist>
            <callout arearefs="hrsample-app">
              <para>The name of the login context that we use for the
              application as registered in the <link
              linkend="frontend.controller">frontend controller</link>.</para>
            </callout>

            <callout arearefs="DevelopmentLoginModule">
              <para>We reference the development login module class.</para>
            </callout>

            <callout arearefs="user">
              <para>The user name the development will check (here
              "demo").</para>
            </callout>

            <callout arearefs="password">
              <para>The user password the development will check (here
              "demo").</para>
            </callout>

            <callout arearefs="roles">
              <para>The comma-separated list of roles (profiles) the logged-in
              user will be assigned (here "administrator"). These roles will
              be checked against when dealing with authorizations.</para>
            </callout>

            <callout arearefs="language">
              <para>Any custom property we want to store in the user
              principal; these properties are kept in a map. Here, we store
              the custom <code>language</code> property as being English. the
              <code>language</code> property is a well-known property that
              will be used by the frontend and backend controllers to apply
              the correct locale for GUI and messages.</para>
            </callout>
          </calloutlist>As you can see, this login module is absolutely not
        suited for production purpose but it is perfect for development since
        you will be able to assign different locales to the logged-in user
        (and thus test for the I18N of the application), or vary the granted
        roles (and thus test for the authorization policies you have set up).
        Moreover, you can feed the user principal with an arbitrary list of
        custom properties your application may need to refer to.</para>

        <para>Of course, other login modules will fetch everything from a
        persistent store and configuring them will be a matter of customizing
        how the user password will be checked and how the user data will be
        retrieved. But the key point is that changing the authorization method
        will just be a matter of changing the <filename>jaas.config</filename>
        file; all the other steps we will go through know will remain
        unchanged.</para>
      </section>

      <section>
        <title>The application startup</title>

        <para>Starting up a Jspresso application actually depends on the GUI
        technology used. Jspresso does the glue between the underlying
        technology and the application code. All the developer has to do is to
        declare the Spring context to be used when launching the application.
        It is done in a startup class that inherits a base class that depends
        on the used GUI technology. Hopefully, the archetype generated all the
        needed startup classes in the <filename>hrsample/startup</filename>
        project module.</para>

        <para><note>
            <para>The different Spring contexts that are to be referenced in
            the startup classes depending on the frontend technology are
            actually defined in the standard Spring bootstrap configuration
            file <filename>beanRefFactory.xml</filename>. Again, this file was
            generated and doesn't need to be modified for standard usage. For
            large applications, you may want to split the generated
            <filename>model.groovy</filename>,
            <filename>view.groovy</filename>,
            <filename>frontend.groovy</filename> and
            <filename>backend.groovy</filename> SJS source files into smaller
            parts. In that case, you need to reflect those splits into the
            bootstrap <filename>application.groovy</filename> file that
            bootstraps the SJS compilation.</para>
          </note></para>

        <para>Even though you won't have to modify startup classes, take some
        time to have a look at what was generated. For instance, you may open
        the <filename>SwingApplicationStartup.java</filename> class that is
        used to lauch the Swing version of the application.</para>

        <para>Here is the code commented :</para>

        <programlisting language="java">package org.jspresso.hrsample.startup.swing;

import org.jspresso.framework.application.startup.swing.SwingStartup;

/**
 * Swing application startup class.
 */
public class SwingApplicationStartup extends SwingStartup { <co
            id="SwingHrSampleStartup" />

  /**
   * Returns the "hrsample-swing-context" value.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  protected String getApplicationContextKey() {
    return "hrsample-swing-context"; <co id="getApplicationContextKey" />
  }
}</programlisting>

        <calloutlist>
          <callout arearefs="SwingHrSampleStartup">
            <para>We inherit from <code>SwingStartup</code> since we are
            starting the application in Swing mode.</para>
          </callout>

          <callout arearefs="getApplicationContextKey">
            <para>Our swing application will use the
            <code>hrsample-swing-context</code> entry we defined in the
            bootstrap <filename>beanRefFactory.xml</filename> file.</para>
          </callout>
        </calloutlist>

        <para>This startup class will be used by a generic swing launcher -
        <code>SwingLauncher</code> - that is declared as the main class of the
        Eclipse launch configuration we have imported in our Eclipse
        workspace.</para>

        <para>You can launch the appication now. You should have a splash
        screen popping up, then a login dialog appears and once the user has
        logged-in (demo/demo as per the <filename>jaas.config</filename>
        file), the entire application is translated in its locale; notice that
        until the user has actually logged in, the frontend controller startup
        locale applies (here, french).</para>

        <para><figure>
            <title>The login dialog with a french startup locale</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/LoginDialog.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure><figure>
            <title>The application main window with an English logged-in
            user</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/AppLaunch_en.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure><figure>
            <title>The application main window with a French logged-in
            user</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/AppLaunch.jpg" scalefit="1"
                           width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para>Of course, this is a very basic launch for a pretty useless
        application... But to make sure that our entities are actually
        registered in hibernate, let's activate the debug mode for the hbm2dll
        tool (remember that we are in the development phase and that we told
        hibernate to regenerate the database schema in HSQL DB at startup);
        edit the <filename>log4j.properties</filename> file at the root of the
        classpath and uncomment the following line :<programlisting>#log4j.logger.org.hibernate.tool.hbm2ddl=DEBUG</programlisting></para>

        <para>You should obtain the following traces in the console :</para>

        <para><programlisting>INFO  org.hibernate.tool.hbm2ddl.SchemaUpdate : Running hbm2ddl schema update
INFO  org.hibernate.tool.hbm2ddl.SchemaUpdate : fetching database metadata
INFO  org.hibernate.tool.hbm2ddl.SchemaUpdate : updating schema
INFO  org.hibernate.tool.hbm2ddl.DatabaseMetadata : table not found: CITY
...
DEBUG org.hibernate.tool.hbm2ddl.SchemaUpdate : create table CITY (ID varchar(36) not null,
             VERSION integer not null,
             ZIP varchar(10),
             NAME varchar(64) not null,
             primary key (ID))
...
DEBUG org.hibernate.tool.hbm2ddl.SchemaUpdate : alter table COMPANY
             add constraint FK6372C85DBA3A8814
             foreign key (CONTACT_CITY_ID)
             references CITY
...
INFO  org.hibernate.tool.hbm2ddl.SchemaUpdate : schema update complete</programlisting>We
        will see later how to take care of the profiles (roles) authorizations
        and how the framework will handle it for you with very little
        configuration. But before getting there, we need to install some
        application workspaces and modules.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Creating and registering application workspaces and modules</title>

    <para>Before getting further in this section, let's first agree on what
    application workspaces and modules are. Jspresso defines an application
    module as a projection of the domain model offering services. It is an
    autonomous part of the application that can be registered in workspaces
    which in turn are registered in the frontend controller to make them
    available to the end-user. As of this writing, the built-in frontend
    controllers (Swing, qooxdoo and Flex) create a main application frame and
    give access to the registered workspaces through a menu. Whenever a
    workspace is opened, the workspace modules structure is displayed.</para>

    <para>Since we talk about module structure, let's explore it. A module is
    basically a tree structure with nested sub-modules (refer to the modules
    class diagram to better understand it). The workspace is the root of this
    tree structure and each workspace registered module (and sub-module) is an
    actual application entry point.</para>

    <para>There are 3 different categories of modules :</para>

    <itemizedlist>
      <listitem>
        <para>Simple module : it offers a view (and its attached services) on
        an arbitrary model (if any).</para>
      </listitem>

      <listitem>
        <para>Bean module : it offers a view (and its attached services) on a
        bean (maybe an entity but it is not mandatory; it can be any java
        bean). The contained java bean can be accessed (get / set) at any time
        and the projected view model gets updated accordingly.</para>
      </listitem>

      <listitem>
        <para>Bean collection module : it offers a view (and its attached
        services) on a collection of beans (maybe a collection of entities but
        it is not mandatory; it can be any collection of java beans). The
        contained java beans collection can be accessed (get / set) at any
        time and the projected view model gets updated accordingly.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>The master data management workspace</title>

      <para>The first workspace we will create and register is the master data
      management workspace. It will offer simple C.R.U.D. (<emphasis
      role="bold">C</emphasis>reate <emphasis role="bold">R</emphasis>etrieve
      <emphasis role="bold">U</emphasis>pdate <emphasis
      role="bold">D</emphasis>elete) services on the application master data
      (actually the cities). As always, Jspresso is offering a large range of
      built-in, ready to assemble components to achieve this.</para>

      <section>
        <title>The cities bean collection module</title>

        <para>The first module we will build is a bean collection module
        (actually a filterable one) that offers the end user all the standard
        operations on the cities entities. Let's have a look to the workspace
        and module definition and registration.</para>

        <para>Open the <filename>frontend.groovy</filename> SJS source file
        and add the following :</para>

        <para><programlisting language="groovy">workspace<co id="Workspace" />('masterdata.workspace',
  icon:'masterdata-48x48.png') {<co id="modules" />
  filterModule<co id="abstractFilterableBeanCollectionModule" />('masterdata.cities.module',
    component:'City'<co id="elementComponentDescriptor" />)
}

controller 'hrsample.name',
  ...
  workspaces:['masterdata.workspace'<co id="workspaces" />]</programlisting><calloutlist>
            <callout arearefs="Workspace">
              <para>We declare our new master data management
              workspace.</para>
            </callout>

            <callout arearefs="modules">
              <para>We assign the list of modules belonging to this new
              workspace. The list contains one module which is the cities
              C.R.U.D. module.</para>
            </callout>

            <callout arearefs="abstractFilterableBeanCollectionModule">
              <para>We declare the cities CRUD module.</para>
            </callout>

            <callout arearefs="elementComponentDescriptor">
              <para>We configure the module by referencing the
              <code>City</code> entity as being the content element of this
              C.R.U.D. module.</para>
            </callout>

            <callout arearefs="workspaces">
              <para>We register the master data management workspace in the
              existing frontend controller.</para>
            </callout>
          </calloutlist></para>

        <para>You might notice in the fragment above that there are actually
        very few directives needed to get a fully functionning C.R.U.D. module
        on an entity. Most of the code deals with names, descriptions and
        icons to obtain a nice looking GUI. Of course, there are plenty of
        customizations you can achieve to meet the actual end-user
        requirements (customize the view on the bean collection, the filter,
        the offered services, ...), but none of them is required until you
        actually want to change the default sensible values.</para>

        <para>We are now ready to see the first workspace in action by
        launching the application. The master data workspace will be made
        available in the application frame workspaces menu. Don't hesitate to
        play with it, create some cities, save them, query them applying a
        filter, zoom on a selected one to edit it in a more convenient form,
        reset the list, ... And if you turn on logging for the executed SQL,
        you will see all your statements transmitted to the backend database.
        The screenshots below captures some of the actions we have just talked
        about.</para>

        <table>
          <title>Some screenshots of the master data management
          workspace</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>1- We have just lauched the module.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>2- We are saving 3 cities we've just
                created.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module-3cities.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>

              <row>
                <entry>3- We are querying the database applying a
                filter.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module-filter.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>4- We are going to edit one of the cities individually
                in a form.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module-open.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>

              <row>
                <entry>5- We have installed one of the city in the module tree
                and we edit it.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module-single.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>6- We reset the module content (the database, of
                course, still contains the data).<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="60%"
                                 fileref="../screenshots/Masterdata-module-reloaded.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Next step will consist in structuring a little bit more the
        module tree.</para>
      </section>

      <section>
        <title>Structuring the modules hierarchy</title>

        <para>There might be situations when you would like to structure a
        little bit more how your application modules are organized. This
        implies, for instance, grouping modules into categories and
        sub-categories. Modules grouping can be achieved by using basic
        modules that structure the workspace module hierarchy.</para>

        <para>Consider the following situation where you want to group your
        master data management in sub-categories like "geography", "finance",
        and so on... Of course, our cities management module should go in the
        geography category. This is quite straightforward to declare; look at
        how we slightly modify the workspace description in the following SJS
        fragment :</para>

        <para><programlisting language="groovy">workspace('masterdata.workspace',
  icon:'masterdata-48x48.png') {
  nodeModule<co id="abstractSimpleModule" />('masterdata.geography.module',
    icon:'geography-48x48.png') {<co id="subModules" />
    filterModule('masterdata.cities.module',
      component:'City'
  }
}</programlisting><calloutlist>
            <callout arearefs="abstractSimpleModule">
              <para>We are inserting the category simple module. It is a
              viewless module, so the only thing we have to configure is its
              name, description and icon.</para>
            </callout>

            <callout arearefs="subModules">
              <para>We transfer the existing cities management module as a
              child (sub-module) of the above geography module.</para>
            </callout>
          </calloutlist></para>

        <para>This type of taxonomy can be arbitrarily deep since you can in
        turn put categories modules as sub-modules of others.</para>

        <para>Re-launching the master data management workspace, we wil see
        our new intermediate geography simple module :</para>

        <para><figure>
            <title>The module hiearchy gets structured</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Masterdata-module-structured.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>Introduction to bean modules</title>

        <para>As of now, we have used a simple module and a filtered bean
        collection module. As introduced at the beginning of the section, the
        third type of module is the bean module. This type of module, as
        explained before, gives a view (and services) on a single business
        object.</para>

        <para>If you look back to the screenshots of the master data
        management workspace, you may notice that we haved used such a module
        (screenshot 5) even without knowing it ! This is because one of the
        standard bean collection module actions creates a bean module behind
        the scene and dynamically installs it in the module hierarchy as a
        sub-module. Of course, in this case, it is pretty useless since it
        doesn't offer any extra functionality beyond the ones offered by its
        parent. But don't forget that you may change a lot of things to meet
        any special requirement.</para>

        <para>As a demonstration of this (but actually not really more
        useful), let's customize the view of this bean module to offer a save
        and reload service on the single displayed city.</para>

        <para>Beforehand, we are going to declare the new city component view
        in the <filename>view.groovy</filename> :</para>

        <para><programlisting language="groovy">form('City.module.view',
  parent:'decoratedView'
  columnCount:1<co id="cityColumnCount" />) {
  actionMap<co id="cityActionMap" /> {
    actionList<co id="ActionList" />('FILE'){
      action<co id="saveModuleObjectFrontAction" />(ref:'saveModuleObjectFrontAction')
      action<co id="reloadModuleObjectFrontAction" />(ref:'reloadModuleObjectFrontAction')
    }
  }
}</programlisting><calloutlist>
            <callout arearefs="cityColumnCount">
              <para>For the sake of modifying the view layout, we organize the
              fields in 1 column.</para>
            </callout>

            <callout arearefs="cityActionMap">
              <para>We assign a new action map to this view. Instead of what
              we did previously when referencing a built-in action map, we
              will create a brand new one.</para>
            </callout>

            <callout arearefs="ActionList">
              <para>An action map is a list of action lists; so let's create
              one.</para>
            </callout>

            <callout arearefs="saveModuleObjectFrontAction">
              <para>We register the standard built-in save action.</para>
            </callout>

            <callout arearefs="reloadModuleObjectFrontAction">
              <para>We register the standard built-in reload action.</para>
            </callout>
          </calloutlist></para>

        <para>Once the customized view is declared, we need to register it in
        the bean collection module as follows :</para>

        <para><programlisting language="groovy">workspace('masterdata.workspace',
  icon:'masterdata-48x48.png') {
  nodeModule('masterdata.geography.module',
    icon:'geography-48x48.png') {
    filterModule('masterdata.cities.module',
      component:'City',
      <emphasis role="bold">detailView</emphasis><co
              id="elementViewDescriptor" /><emphasis role="bold">:'City.module.view'</emphasis>)
  }
}</programlisting><calloutlist>
            <callout arearefs="elementViewDescriptor">
              <para>We register the new city view as being the view to use
              when displaying a single city.</para>
            </callout>
          </calloutlist></para>

        <para>We are now ready to re-open the workspace, create a new city and
        display it individually :</para>

        <para><figure>
            <title>The customized city bean module view</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Masterdata-module-single-customized.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>We have seen here one usage of a bean module that is
        implicitly created and installed using an action registered on a bean
        collection module.</para>

        <para>Although this is actually one of the major usage of this type of
        module, another usage consists in giving access to a session
        singleton-like component. For instance, you could explicitly install a
        bean module to allow the logged-in user to edit his personal
        informations. In that particular case, the logged-in user account
        would be used as the module object of the account editing module. The
        question left is how to initialize the user account as the bean module
        object? Every Jspresso application module provides a startup hook that
        gets triggered when the module is first selected by the end-user. So
        in this case, you would code a custom startup action to retrieve the
        logged-in user informations from whatever backing store (LDAP for
        instance), wrap them in a java bean and set the result as the bean
        module object. This startup action is then registered in the module
        description as its <code>startupAction</code>. This somewhat advanced
        topic is beyond the scope of this section, but read further to learn
        how to write custom actions and remember that you can register them as
        being startup-triggered at different places in a Jspresso application
        i.e. controller (when the application starts) workspace (when the
        workspace is opened for the first time) and modules (when the module
        is first selected).</para>
      </section>
    </section>

    <section>
      <title>Improving the development lifecycle : setting-up test data on
      startup</title>

      <para>One thing that you might have noticed is that the usage of an
      in-memory development database leads to a waste of time creating sample
      data to test the different modules and services. A good practice is to
      ease the developer job by setting-up test data each time the application
      starts. There are actually different ways to achieve that ranging from
      launching a SQL script when starting the application to registering a
      startup triggered action in the controller; but one of the preferred,
      more robust and less intrusive way to do it is to write a dedicated
      startup class that inherits from the default one and that persists a
      complete test domain before actually starting the frontend controller.
      This way, you directly manipulate your domain objects, your business
      rules are enforced and your domain structure is checked at compile time;
      you then basically stay away from seeing your test data becoming
      obsolete after a major refactoring and you keep this setup agnostic of
      the implementation details (nature of the targeted database for
      instance).</para>

      <para>It is also a good idea to centralize the test data production in a
      separate class that can be used by the various development startup class
      thus avoiding un-needed duplication of code. Jspresso offers an abstract
      base class for this task - <code>AbstractTestDataPersister</code> - on
      which you simply have to override the <code>persistTestData()</code>
      method.</para>

      <para>The Jspresso archetype generated a skeleton for you that you have
      to complement with your test data :
      <code>org.jspresso.hrsample.development.TestDataPersister</code>. You
      also imported a launch configuration that allows you to start the
      application with test data in place.</para>

      <para>So let's write this simple test data production class for the HR
      application :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.development;

import java.text.ParseException;
import java.text.SimpleDateFormat;

import org.jspresso.framework.application.startup.development.AbstractHibernateTestDataPersister;
import org.springframework.beans.factory.BeanFactory;

import org.jspresso.hrsample.model.City;
import org.jspresso.hrsample.model.Company;
import org.jspresso.hrsample.model.Department;
import org.jspresso.hrsample.model.Employee;
import org.jspresso.hrsample.model.Team;

/**
 * Persists some test data for the HR sample application.
 */
public class TestDataPersister extends AbstractHibernateTestDataPersister {

  /**
   * Constructs a new &lt;code&gt;TestDataPersister&lt;/code&gt; instance.
   *
   * @param beanFactory
   *            the spring bean factory to use.
   */
  public TestDataPersister(BeanFactory beanFactory) {
    super(beanFactory);
  }

  /**
   * Creates some test data using the passed in Spring application context.
   */
  @Override
  public void persistTestData() {

    // Cities
    City paris = createCity("Paris I", "75001");
    City suresnes = createCity("Suresnes", "92150");
    City evry = createCity("Evry", "91000");

    // Company
    Company design2see = createCompany("Design2See",
        "123 avenue de la Liberté", paris, "contact@design2see.com",
        "+33 123 456 000");

    // Employees
    Employee johnDoe = createEmployee("M", "Doe", "John",
        "12 allée du Chien qui Fume", evry, "john.doe@design2see.com",
        "+33 1 152 368 984", "02/05/1972", "03/08/2005", "1523698754",
        design2see);

    Employee mikeDen = createEmployee("M", "Den", "Mike",
        "26 rue de la Pie qui Chante", suresnes, "mike.den@design2see.com",
        "+33 1 968 846 398", "05/07/1970", "01/03/2004", "1859637461",
        design2see);

    Employee evaGreen = createEmployee("F", "Green", "Eva",
        "68 rue de l'Eléphant Vert", suresnes, "eva.green@design2see.com",
        "+33 1 958 536 972", "10/08/1977", "06/04/2002", "2856752387",
        design2see);

    Employee gloriaSan = createEmployee("F", "San", "Gloria",
        "13 avenue du Poisson Enragé", evry, "gloria.san@design2see.com",
        "+33 1 956 367 412", "09/01/1969", "03/01/2006", "2597853274",
        design2see);

    Employee mariaTrulli = createEmployee("F", "Trulli", "Maria",
        "20 avenue du Crocodile Marteau", evry, "maria.trulli@design2see.com",
        "+33 1 868 745 369", "01/02/1976", "03/10/2006", "2325985423",
        design2see);

    Employee isabelleMartin = createEmployee("F", "Martin", "Isabelle",
        "20 allée de la Gazelle Sauteuse", evry,
        "isabelle.martin@design2see.com", "+33 1 698 256 365", "04/07/1970",
        "12/06/2001", "2652398751", design2see);

    // Departments and teams.
    Department hrDepartment = createDepartment("Human Resources", "HR-000",
        "124 avenue de la Liberté", paris, "hr@design2see.com",
        "+33 123 456 100", design2see, johnDoe);

    Team hr001Team = createTeam("HR 001 Team", "HR-001",
        "124 avenue de la Liberté", paris, "hr001@design2see.com",
        "+33 123 456 101", hrDepartment, mikeDen);
    hr001Team.addToMembers(johnDoe);
    hr001Team.addToMembers(mikeDen);

    Team hr002Team = createTeam("HR 002 Team", "HR-002",
        "124 avenue de la Liberté", paris, "hr002@design2see.com",
        "+33 123 456 102", hrDepartment, evaGreen);
    hr002Team.addToMembers(johnDoe);
    hr002Team.addToMembers(evaGreen);

    Department itDepartment = createDepartment("Information Technology",
        "IT-000", "125 avenue de la Liberté", paris, "it@design2see.com",
        "+33 123 456 200", design2see, gloriaSan);

    Team it001Team = createTeam("IT 001 Team", "IT-001",
        "125 avenue de la Liberté", paris, "it001@design2see.com",
        "+33 123 456 201", itDepartment, mariaTrulli);
    it001Team.addToMembers(gloriaSan);
    it001Team.addToMembers(mariaTrulli);

    Team it002Team = createTeam("IT 002 Team", "IT-002",
        "125 avenue de la Liberté", paris, "it002@design2see.com",
        "+33 123 456 202", itDepartment, isabelleMartin);
    it002Team.addToMembers(gloriaSan);
    it002Team.addToMembers(isabelleMartin);

    saveOrUpdate(design2see);
  }

  private City createCity(String name, String zip) {
    City city = createEntityInstance(City.class);
    city.setName(name);
    city.setZip(zip);
    saveOrUpdate(city);
    return city;
  }

  private Company createCompany(String name, String address, City city,
      String email, String phone) {
    Company company = createEntityInstance(Company.class);
    company.setName(name);
    company.getContact().setAddress(address);
    company.getContact().setCity(city);
    company.getContact().setEmail(email);
    company.getContact().setPhone(phone);
    return company;
  }

  private Department createDepartment(String name, String ouId, String address,
      City city, String email, String phone, Company company, Employee manager) {
    Department department = createEntityInstance(Department.class);
    department.setName(name);
    department.setOuId(ouId);
    department.getContact().setAddress(address);
    department.getContact().setCity(city);
    department.getContact().setEmail(email);
    department.getContact().setPhone(phone);
    department.setCompany(company);
    department.setManager(manager);
    return department;
  }

  private Team createTeam(String name, String ouId, String address, City city,
      String email, String phone, Department department, Employee manager) {
    Team team = createEntityInstance(Team.class);
    team.setName(name);
    team.setOuId(ouId);
    team.getContact().setAddress(address);
    team.getContact().setCity(city);
    team.getContact().setEmail(email);
    team.getContact().setPhone(phone);
    team.setDepartment(department);
    team.setManager(manager);
    return team;
  }

  private Employee createEmployee(String gender, String name, String firstName,
      String address, City city, String email, String phone, String birthDate,
      String hireDate, String ssn, Company company) {
    SimpleDateFormat df = new SimpleDateFormat("DD/MM/yyyy");

    Employee employee = createEntityInstance(Employee.class);
    employee.setGender(gender);
    employee.setName(name);
    employee.setFirstName(firstName);
    employee.getContact().setAddress(address);
    employee.getContact().setCity(city);
    employee.getContact().setEmail(email);
    employee.getContact().setPhone(phone);
    try {
      employee.setBirthDate(df.parse(birthDate));
    } catch (ParseException ex) {
      ex.printStackTrace(System.err);
    }
    try {
      employee.setHireDate(df.parse(hireDate));
    } catch (ParseException ex) {
      ex.printStackTrace(System.err);
    }
    employee.setSsn(ssn);
    employee.setCompany(company);
    return employee;
  }
}</programlisting></para>

      <para>As you can see in the code above, we have set up the test data by
      simply creating and composing some domain entities in plain java.</para>

      <para>You can now have a look to the Swing development startup class
      (<code>org.jspresso.hrsample.startup.swing.development.SwingDevApplicationStartup</code>)
      that already exists in your project code base and that is used by the
      development launch configuration :</para>

      <para><programlisting language="java">package org.jspresso.hrsample.startup.swing.development;

import org.jspresso.hrsample.development.TestDataPersister;
import org.jspresso.hrsample.startup.swing.SwingApplicationStartup;

/**
 * Swing development application startup class.
 */
public class SwingDevApplicationStartup extends SwingApplicationStartup {

  /**
   * Sets up some test data before actually starting.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  public void start() {
    new TestDataPersister(getApplicationContext()).persistTestData(); <co
            id="dev-start" />
    super.start();
  }
}</programlisting></para>

      <para><calloutlist>
          <callout arearefs="dev-start">
            <para>Before actually launching the application, we persist the
            test data produced by the test data persister.</para>
          </callout>
        </calloutlist></para>
    </section>

    <section>
      <title>Developing the remaining workspaces</title>

      <para>In this section, we will create and register the remaining
      workspaces and modules to work on the employees and the organization
      design. We will reuse the concepts that we've discussed when dealing
      with the master data management module and adapt them to the
      corresponding domain windows.</para>

      <section>
        <title>The employees management workspace</title>

        <para>As for the cities module, the employees management module will
        offer CRUD operations. For the sake of simplicity, this module will
        not be linked to a particular company and thus allows employees to be
        managed for any existing company in the database. Since it would be
        too cumbersome to include all the source code in this tutorial and
        since there is hardly anything new, we will only take some screenshots
        of the resulting GUI; but feel free to have a look to the spring
        definition files and to modify them to get a deeper understanding of
        how the workspace is built (don't be afraid, it's only a matter of
        ~100 SJS lines).</para>

        <para>So let's navigate through the employees workspace :</para>

        <table>
          <title>Some screenshots of the employees management
          workspace</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>1- We have just launched the module.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>2- We are querying employees filtering their address
                city and birth date.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-filter.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>

              <row>
                <entry>3- We are editing a single employee in a
                form.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>4- This form gives access to the events of the edited
                employee.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single-events.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>

              <row>
                <entry>5- We can copy an event entity.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single-event-copy.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>6- And paste it to another employee.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single-event-paste.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>

              <row>
                <entry>7- Or maybe read an event text from a file.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single-event-read.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>

                <entry>8- And even save the event text to a file.<mediaobject>
                    <imageobject>
                      <imagedata align="center" contentdepth="40%"
                                 fileref="../screenshots/Employees-module-single-event-save.jpg"
                                 scalefit="1" width="100%" />
                    </imageobject>
                  </mediaobject></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>The organization management workspace</title>

        <para>As for the employee workspace, getting a fully functional
        workspace to be able to edit a company organization is only a matter
        of assembling things that we've already gone through. We will reuse
        the company view we've created in the previous sections as the company
        bean module view. This workspace will be made of several modules. One
        module will allow to edit the company structure in terms of
        organizational units (departments and teams), and a second module will
        allow for managing the teams members.</para>

        <para>So let's navigate through the organization workspace.</para>

        <section>
          <title>Managing companies, departments and teams</title>

          <para>You will find below the screenshots of companies management
          module; they are somehow familiar now.</para>

          <table>
            <title>Some screenshots of the organization management
            workspace</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>1- We have just launched the module.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="40%"
                                   fileref="../screenshots/Companies-module.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>2- We are querying companies without any
                  filter.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="40%"
                                   fileref="../screenshots/Companies-module-filter.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>

                <row>
                  <entry>3- We are editing a single company in a
                  form.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="40%"
                                   fileref="../screenshots/Companies-module-single.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>4- The second tab in the company view gives a tree
                  overview of the current company structure.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="40%"
                                   fileref="../screenshots/Companies-module-single_tree.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Within this module, there is a business rule that needs some
          investigation. Remember the <code>OrganizationalUnit</code> abstract
          entity (<code>Department</code> and <code>Team</code> entities
          inherit from it). We have defined a <code>manager</code>
          relationship to the <code>Employee</code> entity that can be
          visualized in the screenshots above (look at the manager table
          columns). By default, nothing prevents the end user from selecting a
          manager that belongs to another company than the one the
          organizational unit belongs to. So we need to enforce the fact that
          a manager must belong to the same company than the team or
          department (s)he manages.</para>

          <para>There are several steps to enforce this business rule and ease
          the end-user job :</para>

          <itemizedlist>
            <listitem>
              <para>A department is directly linked to a company but a team is
              not; a team belongs to a company through the department it's
              part of. This is quite a good design regarding the model
              normalization but we might want to enrich the API of the
              <code>OrganisationalUnit</code> entity to be able to get its
              company wether it's a <code>Team</code> or a
              <code>Department</code>. It is the perfect situation where we
              need to implement a computed <code>company</code> property held
              by the <code>OrganisationalUnit</code> entity.</para>
            </listitem>

            <listitem>
              <para>We need to enforce the company check business rule when
              setting the manager property on an
              <code>OrganisationalUnit</code> entity. This will ensure that
              any update of the manager property (from the GUI or from any
              other headless interface) will not corrupt the integrity of the
              <code>OrganisationalUnit</code> entity. This is easily
              implemented using a property pre-processor.</para>
            </listitem>

            <listitem>
              <para>We must ease the end-user job in the GUI by
              pre-initializing the employee filter with the organizational
              unit company in the manager LOV and auto-completion
              feature.</para>
            </listitem>
          </itemizedlist>

          <para>Let's have a look to the changes made to the
          application.</para>

          <para>In the <filename>model.groovy</filename> SJS source file
          :</para>

          <para><programlisting language="groovy">Entity('OrganizationalUnit',
    ...
    processor<co id="manager.processor_1" /> :'OrganizationalUnitPropertyProcessors',
    extension<co id="company.computed_1" /> :'OrganizationalUnitExtension') {
  ...
  reference 'manager', id:'OrganizationalUnit-manager', ref:'Employee', mandatory:true,
           processors<co id="manager.processor_2" />:['ManagerProcessor'], initializationMapping<co
                id="initializationMapping" />:['company':'company']
  reference 'company', ref:'Company', computed<co id="company.computed_2" />:true
}</programlisting><calloutlist>
              <callout arearefs="manager.processor_1">
                <para>We declare the class enclosing all the
                <code>OrganizationalUnit</code> property processors. Its
                package is determined by convention based on the current
                namespace, i.e.
                <classname>org.jspresso.hrsample.model.processor.OrganizationalUnitPropertyProcessors</classname>.</para>
              </callout>

              <callout arearefs="company.computed_1">
                <para>We declare the class that is used to compute all derived
                properties of the <code>OrganizationalUnit</code> entiity. Its
                package is determined by convention based on the current
                namespace, i.e.
                <classname>org.jspresso.hrsample.model.extension.OrganizationalUnitExtension</classname>.</para>
              </callout>

              <callout arearefs="manager.processor_2">
                <para>We register an integrity processor that will be
                triggered when a change occurs on the organizational unit
                manager. By convention, it's an internal static class of
                <classname>OrganizationalUnitPropertyProcessors</classname>.</para>
              </callout>

              <callout arearefs="initializationMapping">
                <para>We tell the framework that filter based on the manager
                reference property should pre-initialize its value with the
                following mapping <code>OrganistionalUnit.company</code> -&gt;
                <code>Employee.company</code>. This is a feature that we have
                not seen yet and that is very useful to pre-enforce business
                rules on the GUI side. LOV and auto-completion will both
                benefit from this customization.</para>
              </callout>

              <callout arearefs="company.computed_2">
                <para>We declare a new <code>company</code> computed property
                on the organizational unit entity. The delegate will handle
                the company computing in case of a department or a team. The
                property is computed by the
                <classname>OrganizationalUnitExtension</classname>
                class.</para>
              </callout>
            </calloutlist></para>

          <para>Since we added a property to the
          <code>OrganizationalUnit</code> entity, we need to re-generate it so
          that the accessors are available in the entity interface (<code>mvn
          compile</code> then refresh in Eclipse).</para>

          <para>As before when dealing with property processors and computed
          properties, we need to implement the java delegates.</para>

          <para>We create the
          <code>org.jspresso.hrsample.model.extension.OrganizationalUnitExtension</code>
          class to implement the computed properties on the
          <code>OrganistionalUnit</code> entity; this is the exact same design
          as when we dealt with computing the age of the <code>Employee</code>
          entity :</para>

          <para><programlisting language="java">package org.jspresso.hrsample.model.extension;

import org.jspresso.framework.model.component.AbstractComponentExtension;
import org.jspresso.hrsample.model.Company;
import org.jspresso.hrsample.model.Department;
import org.jspresso.hrsample.model.OrganizationalUnit;
import org.jspresso.hrsample.model.Team;

/**
 * Helper class computing extended properties for OrganizationalUnit entity.
 */
public class OrganizationalUnitExtension extends
    AbstractComponentExtension&lt;OrganizationalUnit&gt; {

  /**
   * Constructs a new &lt;code&gt;OrganizationalUnitExtension&lt;/code&gt; instance.
   *
   * @param organizationalUnit
   *            The extended OrganizationalUnit instance.
   */
  public OrganizationalUnitExtension(OrganizationalUnit organizationalUnit) {
    super(organizationalUnit);
  }

  /**
   * Computes the company this organizational unit is attached to.
   *
   * @return the company this organizational unit is attached to. If the
   *         organizational unit is a department, returns the departments
   *         company; if this organizational unit is a team, then we must
   *         navigate to the enclosing department to get its team.
   */
  public Company getCompany() { <co id="getCompany.computed" />
    if (getComponent() instanceof Team
        &amp;&amp; ((Team) getComponent()).getDepartment() != null) {
      return ((Team) getComponent()).getDepartment().getCompany();
    } else if (getComponent() instanceof Department) {
      return ((Department) getComponent()).getCompany();
    }
    return null;
  }
}</programlisting><calloutlist>
              <callout arearefs="getCompany.computed">
                <para>A pretty simple implementation that deals with concrete
                sublasses of OrganizationalUnit.</para>
              </callout>
            </calloutlist>Finally, we create the
          <code>org.jspresso.hrsample.model.processor.OrganizationalUnitPropertyProcessors</code>
          that holds all property processors of the
          <code>OrganistionalUnit</code> entity; this is the exact same design
          as when we dealt with checking the birth date of the
          <code>Employee</code> entity :</para>

          <para><programlisting language="java">package org.jspresso.hrsample.model.processor;

import org.jspresso.framework.util.bean.integrity.EmptyPropertyProcessor;
import org.jspresso.framework.util.bean.integrity.IntegrityException;
import org.jspresso.hrsample.model.Employee;
import org.jspresso.hrsample.model.OrganizationalUnit;

/**
 * OrganizationalUnit property processors.
 */
public class OrganizationalUnitPropertyProcessors {

  /**
   * Manager property processor.
   */
  public static class ManagerProcessor extends
      EmptyPropertyProcessor&lt;OrganizationalUnit, Employee&gt; { <co
                id="ManagerProcessor" />

    /**
     * Checks that the manager belongs to the same company as the managed
     * OrganizationalUnit.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public void preprocessSetter(OrganizationalUnit organizationalUnit, <co
                id="manager.preprocessSetter" />
        Employee newManager) {
      if (newManager == null || newManager.getCompany() == null
          || !newManager.getCompany().equals(organizationalUnit.getCompany())) {
        throw new IntegrityException(
            "A manager must belong to the same company as its managed organizational unit.",
            "manager.company.invalid");
      }
    }
  }
}</programlisting><calloutlist>
              <callout arearefs="ManagerProcessor">
                <para>Following the recommended design for property
                processors, the manager property processor is implemented as
                an inner class of the enclosing
                <code>OrganizationalUnitPropertyProcessors</code>
                class.</para>
              </callout>

              <callout arearefs="manager.preprocessSetter">
                <para>We need to pre-process the manager setter to check for
                the manager company to be the same as the company of the
                managed organizational unit. Whenever the rule is violated, an
                integrity exception is thrown.</para>
              </callout>
            </calloutlist>Let's see a few screenshots to demonstrate the
          result of the various changes we did. For the sake of the
          demonstration, we have created a second company along with an
          employee and we will try to use this new employee as the manager in
          one of the sample departments.</para>

          <table>
            <title>Some screenshots to show the manager business rule
            enforcement</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>1- We will trigger the list of value to change the
                  department manager.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="45%"
                                   fileref="../screenshots/Companies-module-single-manager-lov.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>2- The LOV dialog opens with a pre-initialized filter
                  containing the department company.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="35%"
                                   fileref="../screenshots/Companies-module-single-manager-lov-open.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>

                <row>
                  <entry>3- Let's reset the filter, and search for the
                  employee of the other company.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="35%"
                                   fileref="../screenshots/Companies-module-single-manager-lov-search.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>4- Select it as the new manager; the business rule is
                  violated and the end-user is notified.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="50%"
                                   fileref="../screenshots/Companies-module-single-manager-lov-error.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section>
          <title>Managing team members</title>

          <para>Managing team members will give us the oportunity to introduce
          the Jspresso action framework. Actually, we have already used action
          maps and action lists to assemble simple standard CRUD operations in
          views (refer to the master-detail action map). This time, we need to
          go a little bit further since there is no out-of-the-box action to
          cover our needs. But don't be afraid, we will still compose Jspresso
          standard actions without writing a single line of java code !</para>

          <para>We will compose 2 actions to manage team members :</para>

          <itemizedlist>
            <listitem>
              <para>The end-user can select an employee and add it to the
              selected team. Of course, the application must filter the
              employees of the company the team belongs to.</para>
            </listitem>

            <listitem>
              <para>The end-user can select an existing team member and remove
              it from the team.</para>
            </listitem>
          </itemizedlist>

          <para>These 2 actions will be presented by a view that lists the
          team members of the selected team in the company management module
          (a somehow classic master-detail view between teams and team
          members). One thing that you may not pay attention to, and this is
          quite normal since Jspresso handles it transparently, is the fact
          that the relationship between teams and employees is a
          bi-directional N-N association. We will handle here one of the
          association side exactly as if it was a 1-N relationship. All the
          inherent complexity of this kind of association will be managed
          behind the scene without any extra effort.</para>

          <para>So let's replace the teams view by a master detail view
          presenting the team members in the <filename>view.groovy</filename>
          :</para>

          <para><programlisting language="groovy">listView<co
                id="Team-Members.table" />('Team-Members.list'<co
                id="Team-Members" />) {
  actionMap<co id="Members-actionMap" /> {
    actionList<co id="Members-actionList" />('EDIT'){<co
                id="Members-actions" />
      action(parent:'lovAction'<co id="lovAction" />,
        custom:[
          autoquery:false<co id="autoquery" />,
          entityDescriptor_ref:'Employee'<co id="lovAction-entityDescriptor" />,
          initializationMapping:['company':'company']<co
                id="lovAction-initializationMapping" />,
          okAction_ref<co id="lovOkFrontAction" />:'addAnyToMasterFrontAction'<co
                id="AddAnyCollectionToMasterAction" />
        ]
      )
      action(ref:'removeAnyCollectionFromMasterFrontAction')<co
                id="removeAnyCollectionFromMasterFrontAction" />
    }
  }
}

split_vertical('Departments.and.teams.view',
  cascadingModels:true,
  top:'Company-departments.table') {
  bottom {
    split_horizontal<co id="department-rightBottomViewDescriptor" /> (
      left<co id="team-rightBottomViewDescriptor" />:'Department-teams.table',
      right:'Team-Members.list',
      cascadingModels:true<co id="teams-cascadingModels" />
    )
  }
}</programlisting><calloutlist>
              <callout arearefs="Team-Members.table">
                <para>We declare a new list view to present the team members
                of a team.</para>
              </callout>

              <callout arearefs="Team-Members">
                <para>This view is backed by the team -&gt; team members
                relationship.</para>
              </callout>

              <callout arearefs="Members-actionMap">
                <para>We assemble a brand new action map (map of action lists)
                for this view. This action map will contain a single action
                list that holds our 2 actions.</para>
              </callout>

              <callout arearefs="Members-actionList">
                <para>We declare the single action list...</para>
              </callout>

              <callout arearefs="Members-actions">
                <para>... and the actions it holds.</para>
              </callout>

              <callout arearefs="lovAction">
                <para>The selection action is a kind of list of values (LOV)
                action (listing existing employees). We reuse the built-in
                Jspresso LOV action (actually inheriting its spring
                definition) and customize it to meet our needs.</para>
              </callout>

              <callout arearefs="autoquery">
                <para>We don't want to query the backend for all available
                employees as soon as the end-user triggers the action; it is
                an arbitrary decision that is lead by the fact that a company
                may actually employ thousands of people ! So let the end-user
                fill-in some criteria before actually triggering the
                search.</para>
              </callout>

              <callout arearefs="lovAction-entityDescriptor">
                <para>The LOV action retrieves employees so we configure it
                accordingly.</para>
              </callout>

              <callout arearefs="lovAction-initializationMapping">
                <para>As for relationships, we initialize the LOV filter with
                the company of the selected team.</para>
              </callout>

              <callout arearefs="lovOkFrontAction">
                <para>Then we need to tell the action what to do when the
                end-user has selected the employee to add...</para>
              </callout>

              <callout arearefs="AddAnyCollectionToMasterAction">
                <para>... by registering another Jspresso built-in action that
                adds an arbitrary collection of objects (in our case the LOV
                selected employee) to the master model on which it was
                triggered (the selected team).</para>
              </callout>

              <callout arearefs="removeAnyCollectionFromMasterFrontAction">
                <para>Removing a team member is somehow easier. We just reuse
                another Jspresso built-in action that removes an arbitrary
                collection of objects (in our case the selected employees)
                from the master model on which it was triggered (the selected
                team).</para>
              </callout>

              <callout arearefs="department-rightBottomViewDescriptor">
                <para>Then we need to slightly update the department and teams
                view to include the team members view.</para>
              </callout>

              <callout arearefs="team-rightBottomViewDescriptor">
                <para>So we register the view created above...</para>
              </callout>

              <callout arearefs="teams-cascadingModels">
                <para>... and configure it to cascade models so that the team
                backing the team members view is retrieved from the selection
                in the department teams view.</para>
              </callout>
            </calloutlist></para>

          <para>With approximately 30 new lines of SJS, you achieve things
          that would normally require hundreds !</para>

          <para>The following screenshots shows the result :</para>

          <table>
            <title>Some screenshots to show the team members
            management</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>1- We display a company organization. notice our new
                  team members view.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="45%"
                                   fileref="../screenshots/Companies-module-single-team-members.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>2- Notice how the 2 actions have been installed and
                  configured (e.g. icons and tooltips).<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="45%"
                                   fileref="../screenshots/Companies-module-single-team-members-2.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>

                <row>
                  <entry>3- Let's trigger the employee selection. The filter
                  is pre-initialized.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="35%"
                                   fileref="../screenshots/Companies-module-single-team-members-lov.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>4- Search for employees filtering on
                  name.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="35%"
                                   fileref="../screenshots/Companies-module-single-team-members-lov-search.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>

                <row>
                  <entry>5- Select one of the employee. The team members is
                  updated.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="45%"
                                   fileref="../screenshots/Companies-module-single-team-members-3.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>

                  <entry>4- Since it is a N-N relationship, the added employee
                  still belongs to its former teams.<mediaobject>
                      <imageobject>
                        <imagedata align="center" contentdepth="45%"
                                   fileref="../screenshots/Companies-module-single-team-members-4.jpg"
                                   scalefit="1" width="100%" />
                      </imageobject>
                    </mediaobject></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Jspresso comes with tens of configurable built-in actions like
          the ones we've just used (wizards, user decisions through pop-ups to
          control the application flow, reporting, file download, ...). This
          is beyond the scope of this section to list them all but remember
          that those built-in actions should cover 100% of your standard
          needs. And whenever you may encounter specific requirements during
          the business analysis, you still have the option to write your own
          actions leveraging the full power of the framework with a whole set
          of abstract action classes to inherit from.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Securing the application access : Authorization</title>

      <para>As we covered it before, securing an application requires 2
      features : authentication and authorization. We've already discussed
      about authentication and JAAS login modules. JAAS also deals with
      authorization but in a way that is strongly related to the java code.
      Basically, it allows for securing java methods and requires
      modifications in the source code.</para>

      <para>The Jspresso framework covers the authorization part in a much
      more declarative and loosely coupled way. All you need to do is to
      declare the granted roles (you may name them profiles or groups) on the
      application component you want to secure the access to. Among the
      securable application components, you will find :</para>

      <itemizedlist>
        <listitem>
          <para>Workspaces</para>
        </listitem>

        <listitem>
          <para>Modules</para>
        </listitem>

        <listitem>
          <para>Actions</para>
        </listitem>

        <listitem>
          <para>Views</para>
        </listitem>

        <listitem>
          <para>View parts like columns in table views or properties in
          component views</para>
        </listitem>

        <listitem>
          <para>Components (and of course entities)</para>
        </listitem>

        <listitem>
          <para>Components (and entities) properties</para>
        </listitem>
      </itemizedlist>

      <para>For workspaces, modules and actions, the end-user will be notified
      that he is not granted access to this part of the application.</para>

      <para>For views and view parts, the framework will simply hide at
      runtime the corresponding graphical component (a table column for
      instance).</para>

      <para>For components and component properties, an access not granted
      will hide all the views (or view parts) backed by the corresponding
      model. Note that the authorization is not enforced on the model itself
      because our experience shows that such a behaviour can lead to really
      problematic side effects. For instance, a user can be granted access to
      an action that behind the scene updates a property (through a component
      service for instance) that he is not granted access to. An unexpected
      security exception then occurs that is hardly understandable... So the
      overall philosophy is to secure the caller and not the callee (the view,
      the web service, ... and not the model).</para>

      <para>The Jspresso login modules assign roles (that may be
      hierarchically declared) to the successfully logged-in user. Then,
      whenever on of the components listed above is solicited by the end user,
      the framework checks the access according to the declared granted
      roles.</para>

      <note>
        <para>An application component with no granted roles assigned is
        considered to be accessible by anyone; this is what we have done until
        now.</para>
      </note>

      <section>
        <title>Restricting access to the application components</title>

        <para>So let's use the 3 profiles we have collected during the
        business requirement : "organization-manager", "staff-manager" and
        "administrator". We will secure the application workspaces accordingly
        :</para>

        <para><programlisting language="groovy">workspace('employees.workspace',
  ...
  grantedRoles<co id="grantedRoles" />:['administrator','staff-manager']) {
  ...
}

workspace('organization.workspace',
  ...
  grantedRoles:['administrator','organization-manager']) {
  ...
}</programlisting><calloutlist>
            <callout arearefs="grantedRoles">
              <para>We grant employees workspace access to the "administrator"
              and "staff-manager" roles. Same applies for the organization
              workspace below.</para>
            </callout>
          </calloutlist></para>

        <para>Believe it or not, you don't have to write anything else! The
        exact same kind of declarations apply to all the securable components.
        It would have been even shorter if we had used a smarter login module
        that had handled groups (or roles) nesting. In that case, we would
        have nest all profiles in the administrator one, making the
        administrator inherit all the authorizations of its nested groups.
        Then we could simply have omitted the administrator declaration in the
        workspaces granted roles.</para>
      </section>

      <section>
        <title>Testing the authorizations enforcement</title>

        <para>The Jspresso development login module allows for arbitrarily
        changing the user role so that authorization can be quickly and
        efficiently tested. We will use this feature to test the workspace
        restrictions that we have declared above.</para>

        <para>So let's assign the <quote>staff-manager</quote> role to our
        demo user by modifying the configuration of the development login
        module in the <filename>jaas.config</filename> file :</para>

        <para><programlisting>/** Login Configuration for the HR sample application **/

hrsample {
   org.jspresso.framework.security.auth.spi.DevelopmentLoginModule required
       user=demo
       password=demo
       roles="staff-manager" <co id="staff-manager" />
       custom.language=en;
};</programlisting><calloutlist>
            <callout arearefs="staff-manager">
              <para>When logged-in, the demo user will be assigned the
              <quote>staff-manager</quote> role. You can even assign multiple
              roles to the development user by listing them separated by
              comas; in that case, the JAAS configuration syntax makes the use
              of double quotes mandatory to surround the list.</para>
            </callout>
          </calloutlist></para>

        <para>When you then try to launch the organization workspace, the
        following notification pops-up :</para>

        <figure>
          <title>Access denied on workspace</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" contentdepth="60%"
                         fileref="../screenshots/Access-denied.jpg"
                         scalefit="1" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>An other example of authorization enforcement might be that you
        want to hide all the tracing properties unless the logged-in user is
        "administrator"; simply add the corresponding granted roles on the
        tracing property descriptors and all your GUI will be instantly
        impacted.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Packaging and deploying</title>

    <para>Last but not least, we need to package and deploy the final
    application. Choosing the target environment highly depends on the
    requirements. Jspresso supports as of now 5 different deployment scenarios
    : Swing, AJAX (<ulink url="http://qooxdoo.org">qooxdoo</ulink>) and Flash
    (<ulink url="http://flex.org/">Flex</ulink>).</para>

    <section>
      <title>A quick overview of options</title>

      <para>For swing you should simply package your application classes and
      resources in a jar (or multiple jars) and distribute it on the clients
      either manually or through a more advanced deployement mechanism like
      <ulink url="http://java.sun.com/products/javawebstart">Java Web
      Start</ulink>. Be aware in that case that the client JVM will handle
      everything except the database and that the network will support the
      JDBC calls from the application backend. This 2-tier architecture is
      certainly not the preferred scenario when you have limited bandwith
      between the clients and the server or limited resources on the client
      machines but it might perfectly fit for a limited number of clients
      residing on the same LAN than the database server. Although, this option
      is not commonly considered as a good option, it should not be
      underestimated especially when dealing with small-scale
      deployments.</para>

      <para>Qooxdoo and Flex deployments require a servlet 2.5 compatible
      application server (<ulink url="http://tomcat.apache.org/">Apache
      tomcat</ulink> is one of them, free and production-robust). This means
      that you can just package your application as a WAR archive and drop it
      in the application server to have it deployed. Jspresso, although very
      powerful and flexible doesn't require an overkilling, latest
      specifications compliant, application server. Once this is said, there
      are times when your application specific needs might require one of
      them. For instance, if you need some heterogeneous transaction
      capability and must use a full fledged JTA compliant transaction
      service, you have little other choice than going to one of the market
      big application servers. Of course, we encourage you to stay in the free
      and opensource world.</para>

      <para>We won't discuss here the database side since Jspresso database
      support is directly linked to the Hibernate database support.</para>

      <note>
        <para>Refer to the Hibernate documentation to get a complete
        understanding of the support and limitations of the database engine
        you plan to deploy. By the way, you will rarely find any limitation on
        this side regarding the huge and excellent support Hibernate has on
        almost each and every common database vendors.</para>
      </note>

      <para>Jspresso introduced with the 3.0 release a native support for
      Adobe's Flex. As for the other deployment options, there is absolutely
      nothing to code against the Flex API (no MXML, no ActionScript).
      Jspresso takes care at runtime of the frontend display and client/server
      communication through :</para>

      <itemizedlist>
        <listitem>
          <para>a generic Flex rendering engine that reads everything it needs
          from the server side</para>
        </listitem>

        <listitem>
          <para>a generic communication layer based on <ulink
          url="http://opensource.adobe.com/wiki/display/blazeds/BlazeDS/">BlazeDS</ulink>
          that takes care of exchanging low-level GUI commands back and forth
          with the server.</para>
        </listitem>
      </itemizedlist>

      <para>Your Jspresso application will then be able to run in any Flash
      enabled browser.</para>

      <para>Starting from the 3.5 release, Jspresso supports <ulink
      url="http://qooxdoo.org">qooxdoo</ulink>, a very high quality Javascript
      UI library (qooxdoo is actually more than that, so feel free to dig into
      their web site). The Jspresso qooxdoo UI channel shares the same
      architecture than the Flex UI channel. Beyond the custom qooxdoo java
      RPC servlet, the same codebase is used to adapt the client server
      communication.</para>

      <para>Whatever option you take to deploy your Jspresso application (you
      may choose all of them), everything is already prepared in the project
      and the Maven build will take care of every complicated packaging
      steps.</para>
    </section>

    <section>
      <title>Packaging the application WAR archive</title>

      <para>Surely the shortest section of the manual. Just launch :</para>

      <blockquote>
        <para><code>mvn package</code></para>
      </blockquote>

      <para>Go to <filename>hrsample/webapp/target/</filename> and you will
      have a ready-to deploy war archive containing your Jspresso application.
      The generated Jspresso project is also ready to to be used in Eclipse
      WTP. Just add it to the Eclipse managed Tomcat you've created when
      setting-up the development environment and start the server.</para>
    </section>

    <section>
      <title>Deploying to the application server</title>

      <para>Now that you have a complete WAR archive, it is time to deploy it
      in the application server. This step highly depends on the application
      server you will choose and ranges from a simple copy into a deployment
      directory to the use of a specific deployment tool; so refer to the
      documentation of your J2EE server to know how to perform this task. As
      an example, in the Apache Tomcat AS, deploying a WAR is a matter of
      copying it to the <filename>webapps/</filename> directory.</para>

      <para>There is still one thing to achieve before being able to go live.
      The JAAS configuration (held in the <filename>jaas.config</filename>
      file) is a per-JVM configuration. This means that you cannot package
      your <filename>jaas.config</filename> file into the WAR itself, but you
      need to make it accessible somewhere in the environment so that you can
      refer to it in the <code>java.security.auth.login.config</code> java
      system property on the application server JVM level (as we did it at
      development time for the standalone swing application). The
      <filename>jaas.config</filename> file will then gather the JAAS
      configurations of <emphasis>all</emphasis> the applications deployed in
      your server. Again, refer to the documentation of your J2EE server to
      know how to set a java system property in your application server
      instance. As an example, in the Apache Tomcat AS, setting a system
      property is achieved by setting the <code>CATALINA_OPTS</code>
      environment variable, e.g. :</para>

      <blockquote>
        <para><code>CATALINA_OPTS=-Djava.security.auth.login.config=/path/to/my/jaas.config</code></para>
      </blockquote>

      <para>We can now see the result of the deployment.</para>

      <section>
        <title>The first Flex launch</title>

        <para>Point your browser to the <code>flex</code> context :</para>

        <blockquote>
          <para><code>http://[machine]:[port]/hrsample-webapp/flex/</code></para>
        </blockquote>

        <para>The browser shows you the Flex login dialog.</para>

        <para><figure>
            <title>The browser displays the Flex login dialog</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Flex_login.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>And you can play with the same application but in Flash
        !</para>

        <para><figure>
            <title>You query the companies in Flex !</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="40%"
                           fileref="../screenshots/Flex_application.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section>
        <title>The first qooxdoo launch</title>

        <para>Point your browser to the <code>qooxdoo</code> context :</para>

        <blockquote>
          <para><code>http://[machine]:[port]/hrsample-webapp/qooxdoo/</code></para>
        </blockquote>

        <para>The browser shows you the qooxdoo login dialog.</para>

        <para><figure>
            <title>The browser displays the qooxdoo login dialog</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="60%"
                           fileref="../screenshots/Qooxdoo_login.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure>And you can play with the same application but in
        Javascript using the qooxdoo library !</para>

        <para><figure>
            <title>You query the companies in qooxdoo !</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" contentdepth="40%"
                           fileref="../screenshots/Qooxdoo_application.jpg"
                           scalefit="1" width="100%" />
              </imageobject>
            </mediaobject>
          </figure></para>

        <para></para>

        <para>Congratulations! we have now closed the circle and in tenth of
        the effort usually required to achieve the equivalent, we developped
        and deployed a multi-channel, distributed desktop-like business
        application.</para>
      </section>
    </section>
  </section>
</chapter>
